#!/bin/bash
#
# Contains a mapping of a git repo paths to a comma-separated list of the according local
# branch name and remote branch names to pull from and push to.
# Also contains helper functions to use the mapping.
#
# The mapping contains repos that may be worked with together.

# This is the mapping of repo paths to branch names. Adjust to your needs.
declare -A repo_paths2default_branch_names=(
    ["${HOME}/dotfiles"]='master,master,master'
    ["${HOME}/scripts"]='master,master,master'
    ["${HOME}/my-scripts"]='master,master,master'
)

# sanity check
for repo in "${!repo_paths2default_branch_names[@]}"; do
        branch_names_string="${repo_paths2default_branch_names[${repo}]}";
        IFS=',' read -r -a branch_names <<< "${branch_names_string}"

        if [ ${#branch_names[@]} != 3 ] ; then
            output="Error in ${BASH_SOURCE[0]} sourced by ${0}: Repo ${repo}'s branch names array"
            output="${output} is malformed: ${branch_names[@]}. It should contain 3 exactly"
            output="${output} branches in the form (local,remote pull, remote push), but does not."
            >&2 printf "${output}\n"
        fi
done

# utility functions
function local_branch {
    local branches_string="${repo_paths2default_branch_names[${1}]}";
    IFS=',' read -r -a branches <<< "${branches_string}"
    echo "${branches[0]}"
}

function remote_pull_branch {
    local branches_string="${repo_paths2default_branch_names[${1}]}";
    IFS=',' read -r -a branches <<< "${branches_string}"
    echo "${branches[1]}"
}

function remote_push_branch {
    local branches_string="${repo_paths2default_branch_names[${1}]}";
    IFS=',' read -r -a branches <<< "${branches_string}"
    echo "${branches[2]}"
}
