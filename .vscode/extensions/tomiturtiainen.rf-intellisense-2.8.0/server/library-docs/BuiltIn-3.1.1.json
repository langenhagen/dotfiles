{"name": "BuiltIn", "version": "3.1.1", "keywords": [{"name": "Call Method", "args": ["object", "method_name", "*args", "**kwargs"], "doc": "Calls the named method of the given object with the provided arguments.\n\nThe possible return value from the method is returned and can be\nassigned to a variable. Keyword fails both if the object does not have\na method with the given name or if executing the method raises an\nexception.\n\nSupport for ``**kwargs`` is new in Robot Framework 2.9. Since that\npossible equal signs in other arguments must be escaped with a\nbackslash like ``\\=``.\n\nExamples:\n| Call Method      | ${hashtable} | put          | myname  | myvalue |\n| ${isempty} =     | Call Method  | ${hashtable} | isEmpty |         |\n| Should Not Be True | ${isempty} |              |         |         |\n| ${value} =       | Call Method  | ${hashtable} | get     | myname  |\n| Should Be Equal  | ${value}     | myvalue      |         |         |\n| Call Method      | ${object}    | kwargs    | name=value | foo=bar |\n| Call Method      | ${object}    | positional   | escaped\\=equals  |"}, {"name": "Catenate", "args": ["*items"], "doc": "Catenates the given items together and returns the resulted string.\n\nBy default, items are catenated with spaces, but if the first item\ncontains the string ``SEPARATOR=<sep>``, the separator ``<sep>`` is\nused instead. Items are converted into strings when necessary.\n\nExamples:\n| ${str1} = | Catenate | Hello         | world |       |\n| ${str2} = | Catenate | SEPARATOR=--- | Hello | world |\n| ${str3} = | Catenate | SEPARATOR=    | Hello | world |\n=>\n| ${str1} = 'Hello world'\n| ${str2} = 'Hello---world'\n| ${str3} = 'Helloworld'"}, {"name": "Comment", "args": ["*messages"], "doc": "Displays the given messages in the log file as keyword arguments.\n\nThis keyword does nothing with the arguments it receives, but as they\nare visible in the log, this keyword can be used to display simple\nmessages. Given arguments are ignored so thoroughly that they can even\ncontain non-existing variables. If you are interested about variable\nvalues, you can use the `Log` or `Log Many` keywords."}, {"name": "Continue For Loop", "args": [], "doc": "Skips the current for loop iteration and continues from the next.\n\nSkips the remaining keywords in the current for loop iteration and\ncontinues from the next one. Can be used directly in a for loop or\nin a keyword that the loop uses.\n\nExample:\n| :FOR | ${var}         | IN                     | @{VALUES}         |\n|      | Run Keyword If | '${var}' == 'CONTINUE' | Continue For Loop |\n|      | Do Something   | ${var}                 |\n\nSee `Continue For Loop If` to conditionally continue a for loop without\nusing `Run Keyword If` or other wrapper keywords."}, {"name": "Continue For Loop If", "args": ["condition"], "doc": "Skips the current for loop iteration if the ``condition`` is true.\n\nA wrapper for `Continue For Loop` to continue a for loop based on\nthe given condition. The condition is evaluated using the same\nsemantics as with `Should Be True` keyword.\n\nExample:\n| :FOR | ${var}               | IN                     | @{VALUES} |\n|      | Continue For Loop If | '${var}' == 'CONTINUE' |\n|      | Do Something         | ${var}                 |"}, {"name": "Convert To Binary", "args": ["item", "base=None", "prefix=None", "length=None"], "doc": "Converts the given item to a binary string.\n\nThe ``item``, with an optional ``base``, is first converted to an\ninteger using `Convert To Integer` internally. After that it\nis converted to a binary number (base 2) represented as a\nstring such as ``1011``.\n\nThe returned value can contain an optional ``prefix`` and can be\nrequired to be of minimum ``length`` (excluding the prefix and a\npossible minus sign). If the value is initially shorter than\nthe required length, it is padded with zeros.\n\nExamples:\n| ${result} = | Convert To Binary | 10 |         |           | # Result is 1010   |\n| ${result} = | Convert To Binary | F  | base=16 | prefix=0b | # Result is 0b1111 |\n| ${result} = | Convert To Binary | -2 | prefix=B | length=4 | # Result is -B0010 |\n\nSee also `Convert To Integer`, `Convert To Octal` and `Convert To Hex`."}, {"name": "Convert To Boolean", "args": ["item"], "doc": "Converts the given item to Boolean true or false.\n\nHandles strings ``True`` and ``False`` (case-insensitive) as expected,\notherwise returns item's\n[http://docs.python.org/library/stdtypes.html#truth|truth value]\nusing Python's ``bool()`` method."}, {"name": "Convert To Bytes", "args": ["input", "input_type=text"], "doc": "Converts the given ``input`` to bytes according to the ``input_type``.\n\nValid input types are listed below:\n\n- ``text:`` Converts text to bytes character by character. All\n  characters with ordinal below 256 can be used and are converted to\n  bytes with same values. Many characters are easiest to represent\n  using escapes like ``\\x00`` or ``\\xff``. Supports both Unicode\n  strings and bytes.\n\n- ``int:`` Converts integers separated by spaces to bytes. Similarly as\n  with `Convert To Integer`, it is possible to use binary, octal, or\n  hex values by prefixing the values with ``0b``, ``0o``, or ``0x``,\n  respectively.\n\n- ``hex:`` Converts hexadecimal values to bytes. Single byte is always\n  two characters long (e.g. ``01`` or ``FF``). Spaces are ignored and\n  can be used freely as a visual separator.\n\n- ``bin:`` Converts binary values to bytes. Single byte is always eight\n  characters long (e.g. ``00001010``). Spaces are ignored and can be\n  used freely as a visual separator.\n\nIn addition to giving the input as a string, it is possible to use\nlists or other iterables containing individual characters or numbers.\nIn that case numbers do not need to be padded to certain length and\nthey cannot contain extra spaces.\n\nExamples (last column shows returned bytes):\n| ${bytes} = | Convert To Bytes | hyv\u00e4    |     | # hyv\\xe4        |\n| ${bytes} = | Convert To Bytes | \\xff\\x07 |     | # \\xff\\x07      |\n| ${bytes} = | Convert To Bytes | 82 70      | int | # RF              |\n| ${bytes} = | Convert To Bytes | 0b10 0x10  | int | # \\x02\\x10      |\n| ${bytes} = | Convert To Bytes | ff 00 07   | hex | # \\xff\\x00\\x07 |\n| ${bytes} = | Convert To Bytes | 5246212121 | hex | # RF!!!           |\n| ${bytes} = | Convert To Bytes | 0000 1000  | bin | # \\x08           |\n| ${input} = | Create List      | 1          | 2   | 12                |\n| ${bytes} = | Convert To Bytes | ${input}   | int | # \\x01\\x02\\x0c |\n| ${bytes} = | Convert To Bytes | ${input}   | hex | # \\x01\\x02\\x12 |\n\nUse `Encode String To Bytes` in ``String`` library if you need to\nconvert text to bytes using a certain encoding."}, {"name": "Convert To Hex", "args": ["item", "base=None", "prefix=None", "length=None", "lowercase=False"], "doc": "Converts the given item to a hexadecimal string.\n\nThe ``item``, with an optional ``base``, is first converted to an\ninteger using `Convert To Integer` internally. After that it\nis converted to a hexadecimal number (base 16) represented as\na string such as ``FF0A``.\n\nThe returned value can contain an optional ``prefix`` and can be\nrequired to be of minimum ``length`` (excluding the prefix and a\npossible minus sign). If the value is initially shorter than\nthe required length, it is padded with zeros.\n\nBy default the value is returned as an upper case string, but the\n``lowercase`` argument a true value (see `Boolean arguments`) turns\nthe value (but not the given prefix) to lower case.\n\nExamples:\n| ${result} = | Convert To Hex | 255 |           |              | # Result is FF    |\n| ${result} = | Convert To Hex | -10 | prefix=0x | length=2     | # Result is -0x0A |\n| ${result} = | Convert To Hex | 255 | prefix=X | lowercase=yes | # Result is Xff   |\n\nSee also `Convert To Integer`, `Convert To Binary` and `Convert To Octal`."}, {"name": "Convert To Integer", "args": ["item", "base=None"], "doc": "Converts the given item to an integer number.\n\nIf the given item is a string, it is by default expected to be an\ninteger in base 10. There are two ways to convert from other bases:\n\n- Give base explicitly to the keyword as ``base`` argument.\n\n- Prefix the given string with the base so that ``0b`` means binary\n  (base 2), ``0o`` means octal (base 8), and ``0x`` means hex (base 16).\n  The prefix is considered only when ``base`` argument is not given and\n  may itself be prefixed with a plus or minus sign.\n\nThe syntax is case-insensitive and possible spaces are ignored.\n\nExamples:\n| ${result} = | Convert To Integer | 100    |    | # Result is 100   |\n| ${result} = | Convert To Integer | FF AA  | 16 | # Result is 65450 |\n| ${result} = | Convert To Integer | 100    | 8  | # Result is 64    |\n| ${result} = | Convert To Integer | -100   | 2  | # Result is -4    |\n| ${result} = | Convert To Integer | 0b100  |    | # Result is 4     |\n| ${result} = | Convert To Integer | -0x100 |    | # Result is -256  |\n\nSee also `Convert To Number`, `Convert To Binary`, `Convert To Octal`,\n`Convert To Hex`, and `Convert To Bytes`."}, {"name": "Convert To Number", "args": ["item", "precision=None"], "doc": "Converts the given item to a floating point number.\n\nIf the optional ``precision`` is positive or zero, the returned number\nis rounded to that number of decimal digits. Negative precision means\nthat the number is rounded to the closest multiple of 10 to the power\nof the absolute precision. If a number is equally close to a certain\nprecision, it is always rounded away from zero.\n\nExamples:\n| ${result} = | Convert To Number | 42.512 |    | # Result is 42.512 |\n| ${result} = | Convert To Number | 42.512 | 1  | # Result is 42.5   |\n| ${result} = | Convert To Number | 42.512 | 0  | # Result is 43.0   |\n| ${result} = | Convert To Number | 42.512 | -1 | # Result is 40.0   |\n\nNotice that machines generally cannot store floating point numbers\naccurately. This may cause surprises with these numbers in general\nand also when they are rounded. For more information see, for example,\nthese resources:\n\n- http://docs.python.org/tutorial/floatingpoint.html\n- http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition\n\nIf you want to avoid possible problems with floating point numbers,\nyou can implement custom keywords using Python's\n[http://docs.python.org/library/decimal.html|decimal] or\n[http://docs.python.org/library/fractions.html|fractions] modules.\n\nIf you need an integer number, use `Convert To Integer` instead."}, {"name": "Convert To Octal", "args": ["item", "base=None", "prefix=None", "length=None"], "doc": "Converts the given item to an octal string.\n\nThe ``item``, with an optional ``base``, is first converted to an\ninteger using `Convert To Integer` internally. After that it\nis converted to an octal number (base 8) represented as a\nstring such as ``775``.\n\nThe returned value can contain an optional ``prefix`` and can be\nrequired to be of minimum ``length`` (excluding the prefix and a\npossible minus sign). If the value is initially shorter than\nthe required length, it is padded with zeros.\n\nExamples:\n| ${result} = | Convert To Octal | 10 |            |          | # Result is 12      |\n| ${result} = | Convert To Octal | -F | base=16    | prefix=0 | # Result is -017    |\n| ${result} = | Convert To Octal | 16 | prefix=oct | length=4 | # Result is oct0020 |\n\nSee also `Convert To Integer`, `Convert To Binary` and `Convert To Hex`."}, {"name": "Convert To String", "args": ["item"], "doc": "Converts the given item to a Unicode string.\n\nUses ``__unicode__`` or ``__str__`` method with Python objects and\n``toString`` with Java objects.\n\nUse `Encode String To Bytes` and `Decode Bytes To String` keywords\nin ``String`` library if you need to convert between Unicode and byte\nstrings using different encodings. Use `Convert To Bytes` if you just\nwant to create byte strings."}, {"name": "Create Dictionary", "args": ["*items"], "doc": "Creates and returns a dictionary based on the given ``items``.\n\nItems are typically given using the ``key=value`` syntax same way as\n``&{dictionary}`` variables are created in the Variable table. Both\nkeys and values can contain variables, and possible equal sign in key\ncan be escaped with a backslash like ``escaped\\=key=value``. It is\nalso possible to get items from existing dictionaries by simply using\nthem like ``&{dict}``.\n\nAlternatively items can be specified so that keys and values are given\nseparately. This and the ``key=value`` syntax can even be combined,\nbut separately given items must be first.\n\nIf same key is used multiple times, the last value has precedence.\nThe returned dictionary is ordered, and values with strings as keys\ncan also be accessed using a convenient dot-access syntax like\n``${dict.key}``.\n\nExamples:\n| &{dict} = | Create Dictionary | key=value | foo=bar | | | # key=value syntax |\n| Should Be True | ${dict} == {'key': 'value', 'foo': 'bar'} |\n| &{dict2} = | Create Dictionary | key | value | foo | bar | # separate key and value |\n| Should Be Equal | ${dict} | ${dict2} |\n| &{dict} = | Create Dictionary | ${1}=${2} | &{dict} | foo=new | | # using variables |\n| Should Be True | ${dict} == {1: 2, 'key': 'value', 'foo': 'new'} |\n| Should Be Equal | ${dict.key} | value | | | | # dot-access |\n\nThis keyword was changed in Robot Framework 2.9 in many ways:\n- Moved from ``Collections`` library to ``BuiltIn``.\n- Support also non-string keys in ``key=value`` syntax.\n- Returned dictionary is ordered and dot-accessible.\n- Old syntax to give keys and values separately was deprecated, but\n  deprecation was later removed in RF 3.0.1."}, {"name": "Create List", "args": ["*items"], "doc": "Returns a list containing given items.\n\nThe returned list can be assigned both to ``${scalar}`` and ``@{list}``\nvariables.\n\nExamples:\n| @{list} =   | Create List | a    | b    | c    |\n| ${scalar} = | Create List | a    | b    | c    |\n| ${ints} =   | Create List | ${1} | ${2} | ${3} |"}, {"name": "Evaluate", "args": ["expression", "modules=None", "namespace=None"], "doc": "Evaluates the given expression in Python and returns the results.\n\n``expression`` is evaluated in Python as explained in `Evaluating\nexpressions`.\n\n``modules`` argument can be used to specify a comma separated\nlist of Python modules to be imported and added to the evaluation\nnamespace.\n\n``namespace`` argument can be used to pass a custom evaluation\nnamespace as a dictionary. Possible ``modules`` are added to this\nnamespace.\n\nVariables used like ``${variable}`` are replaced in the expression\nbefore evaluation. Variables are also available in the evaluation\nnamespace and can be accessed using special syntax ``$variable``.\nThis is a new feature in Robot Framework 2.9 and it is explained more\nthoroughly in `Evaluating expressions`.\n\nExamples (expecting ``${result}`` is 3.14):\n| ${status} = | Evaluate | 0 < ${result} < 10 | # Would also work with string '3.14' |\n| ${status} = | Evaluate | 0 < $result < 10   | # Using variable itself, not string representation |\n| ${random} = | Evaluate | random.randint(0, sys.maxint) | modules=random, sys |\n| ${ns} =     | Create Dictionary | x=${4}    | y=${2}              |\n| ${result} = | Evaluate | x*10 + y           | namespace=${ns}     |\n=>\n| ${status} = True\n| ${random} = <random integer>\n| ${result} = 42"}, {"name": "Exit For Loop", "args": [], "doc": "Stops executing the enclosing for loop.\n\nExits the enclosing for loop and continues execution after it.\nCan be used directly in a for loop or in a keyword that the loop uses.\n\nExample:\n| :FOR | ${var}         | IN                 | @{VALUES}     |\n|      | Run Keyword If | '${var}' == 'EXIT' | Exit For Loop |\n|      | Do Something   | ${var} |\n\nSee `Exit For Loop If` to conditionally exit a for loop without\nusing `Run Keyword If` or other wrapper keywords."}, {"name": "Exit For Loop If", "args": ["condition"], "doc": "Stops executing the enclosing for loop if the ``condition`` is true.\n\nA wrapper for `Exit For Loop` to exit a for loop based on\nthe given condition. The condition is evaluated using the same\nsemantics as with `Should Be True` keyword.\n\nExample:\n| :FOR | ${var}           | IN                 | @{VALUES} |\n|      | Exit For Loop If | '${var}' == 'EXIT' |\n|      | Do Something     | ${var}             |"}, {"name": "Fail", "args": ["msg=None", "*tags"], "doc": "Fails the test with the given message and optionally alters its tags.\n\nThe error message is specified using the ``msg`` argument.\nIt is possible to use HTML in the given error message, similarly\nas with any other keyword accepting an error message, by prefixing\nthe error with ``*HTML*``.\n\nIt is possible to modify tags of the current test case by passing tags\nafter the message. Tags starting with a hyphen (e.g. ``-regression``)\nare removed and others added. Tags are modified using `Set Tags` and\n`Remove Tags` internally, and the semantics setting and removing them\nare the same as with these keywords.\n\nExamples:\n| Fail | Test not ready   |             | | # Fails with the given message.    |\n| Fail | *HTML*<b>Test not ready</b> | | | # Fails using HTML in the message. |\n| Fail | Test not ready   | not-ready   | | # Fails and adds 'not-ready' tag.  |\n| Fail | OS not supported | -regression | | # Removes tag 'regression'.        |\n| Fail | My message       | tag    | -t*  | # Removes all tags starting with 't' except the newly added 'tag'. |\n\nSee `Fatal Error` if you need to stop the whole test execution."}, {"name": "Fatal Error", "args": ["msg=None"], "doc": "Stops the whole test execution.\n\nThe test or suite where this keyword is used fails with the provided\nmessage, and subsequent tests fail with a canned message.\nPossible teardowns will nevertheless be executed.\n\nSee `Fail` if you only want to stop one test case unconditionally."}, {"name": "Get Count", "args": ["item1", "item2"], "doc": "Returns and logs how many times ``item2`` is found from ``item1``.\n\nThis keyword works with Python strings and lists and all objects\nthat either have ``count`` method or can be converted to Python lists.\n\nExample:\n| ${count} = | Get Count | ${some item} | interesting value |\n| Should Be True | 5 < ${count} < 10 |"}, {"name": "Get Length", "args": ["item"], "doc": "Returns and logs the length of the given item as an integer.\n\nThe item can be anything that has a length, for example, a string,\na list, or a mapping. The keyword first tries to get the length with\nthe Python function ``len``, which calls the  item's ``__len__`` method\ninternally. If that fails, the keyword tries to call the item's\npossible ``length`` and ``size`` methods directly. The final attempt is\ntrying to get the value of the item's ``length`` attribute. If all\nthese attempts are unsuccessful, the keyword fails.\n\nExamples:\n| ${length} = | Get Length    | Hello, world! |        |\n| Should Be Equal As Integers | ${length}     | 13     |\n| @{list} =   | Create List   | Hello,        | world! |\n| ${length} = | Get Length    | ${list}       |        |\n| Should Be Equal As Integers | ${length}     | 2      |\n\nSee also `Length Should Be`, `Should Be Empty` and `Should Not Be\nEmpty`."}, {"name": "Get Library Instance", "args": ["name=None", "all=False"], "doc": "Returns the currently active instance of the specified test library.\n\nThis keyword makes it easy for test libraries to interact with\nother test libraries that have state. This is illustrated by\nthe Python example below:\n\n| from robot.libraries.BuiltIn import BuiltIn\n|\n| def title_should_start_with(expected):\n|     seleniumlib = BuiltIn().get_library_instance('SeleniumLibrary')\n|     title = seleniumlib.get_title()\n|     if not title.startswith(expected):\n|         raise AssertionError(\"Title '%s' did not start with '%s'\"\n|                              % (title, expected))\n\nIt is also possible to use this keyword in the test data and\npass the returned library instance to another keyword. If a\nlibrary is imported with a custom name, the ``name`` used to get\nthe instance must be that name and not the original library name.\n\nIf the optional argument ``all`` is given a true value, then a\ndictionary mapping all library names to instances will be returned.\nThis feature is new in Robot Framework 2.9.2.\n\nExample:\n| &{all libs} = | Get library instance | all=True |"}, {"name": "Get Time", "args": ["format=timestamp", "time_=NOW"], "doc": "Returns the given time in the requested format.\n\n*NOTE:* DateTime library contains much more flexible keywords for\ngetting the current date and time and for date and time handling in\ngeneral.\n\nHow time is returned is determined based on the given ``format``\nstring as follows. Note that all checks are case-insensitive.\n\n1) If ``format`` contains the word ``epoch``, the time is returned\n   in seconds after the UNIX epoch (1970-01-01 00:00:00 UTC).\n   The return value is always an integer.\n\n2) If ``format`` contains any of the words ``year``, ``month``,\n   ``day``, ``hour``, ``min``, or ``sec``, only the selected parts are\n   returned. The order of the returned parts is always the one\n   in the previous sentence and the order of words in ``format``\n   is not significant. The parts are returned as zero-padded\n   strings (e.g. May -> ``05``).\n\n3) Otherwise (and by default) the time is returned as a\n   timestamp string in the format ``2006-02-24 15:08:31``.\n\nBy default this keyword returns the current local time, but\nthat can be altered using ``time`` argument as explained below.\nNote that all checks involving strings are case-insensitive.\n\n1) If ``time`` is a number, or a string that can be converted to\n   a number, it is interpreted as seconds since the UNIX epoch.\n   This documentation was originally written about 1177654467\n   seconds after the epoch.\n\n2) If ``time`` is a timestamp, that time will be used. Valid\n   timestamp formats are ``YYYY-MM-DD hh:mm:ss`` and\n   ``YYYYMMDD hhmmss``.\n\n3) If ``time`` is equal to ``NOW`` (default), the current local\n   time is used.\n\n4) If ``time`` is equal to ``UTC``, the current time in\n   [http://en.wikipedia.org/wiki/Coordinated_Universal_Time|UTC]\n   is used.\n\n5) If ``time`` is in the format like ``NOW - 1 day`` or ``UTC + 1 hour\n   30 min``, the current local/UTC time plus/minus the time\n   specified with the time string is used. The time string format\n   is described in an appendix of Robot Framework User Guide.\n\nExamples (expecting the current local time is 2006-03-29 15:06:21):\n| ${time} = | Get Time |             |  |  |\n| ${secs} = | Get Time | epoch       |  |  |\n| ${year} = | Get Time | return year |  |  |\n| ${yyyy}   | ${mm}    | ${dd} =     | Get Time | year,month,day |\n| @{time} = | Get Time | year month day hour min sec |  |  |\n| ${y}      | ${s} =   | Get Time    | seconds and year |  |\n=>\n| ${time} = '2006-03-29 15:06:21'\n| ${secs} = 1143637581\n| ${year} = '2006'\n| ${yyyy} = '2006', ${mm} = '03', ${dd} = '29'\n| @{time} = ['2006', '03', '29', '15', '06', '21']\n| ${y} = '2006'\n| ${s} = '21'\n\nExamples (expecting the current local time is 2006-03-29 15:06:21 and\nUTC time is 2006-03-29 12:06:21):\n| ${time} = | Get Time |              | 1177654467          | # Time given as epoch seconds        |\n| ${secs} = | Get Time | sec          | 2007-04-27 09:14:27 | # Time given as a timestamp          |\n| ${year} = | Get Time | year         | NOW                 | # The local time of execution        |\n| @{time} = | Get Time | hour min sec | NOW + 1h 2min 3s    | # 1h 2min 3s added to the local time |\n| @{utc} =  | Get Time | hour min sec | UTC                 | # The UTC time of execution          |\n| ${hour} = | Get Time | hour         | UTC - 1 hour        | # 1h subtracted from the UTC  time   |\n=>\n| ${time} = '2007-04-27 09:14:27'\n| ${secs} = 27\n| ${year} = '2006'\n| @{time} = ['16', '08', '24']\n| @{utc} = ['12', '06', '21']\n| ${hour} = '11'"}, {"name": "Get Variable Value", "args": ["name", "default=None"], "doc": "Returns variable value or ``default`` if the variable does not exist.\n\nThe name of the variable can be given either as a normal variable name\n(e.g. ``${NAME}``) or in escaped format (e.g. ``\\${NAME}``). Notice\nthat the former has some limitations explained in `Set Suite Variable`.\n\nExamples:\n| ${x} = | Get Variable Value | ${a} | default |\n| ${y} = | Get Variable Value | ${a} | ${b}    |\n| ${z} = | Get Variable Value | ${z} |         |\n=>\n| ${x} gets value of ${a} if ${a} exists and string 'default' otherwise\n| ${y} gets value of ${a} if ${a} exists and value of ${b} otherwise\n| ${z} is set to Python None if it does not exist previously\n\nSee `Set Variable If` for another keyword to set variables dynamically."}, {"name": "Get Variables", "args": ["no_decoration=False"], "doc": "Returns a dictionary containing all variables in the current scope.\n\nVariables are returned as a special dictionary that allows accessing\nvariables in space, case, and underscore insensitive manner similarly\nas accessing variables in the test data. This dictionary supports all\nsame operations as normal Python dictionaries and, for example,\nCollections library can be used to access or modify it. Modifying the\nreturned dictionary has no effect on the variables available in the\ncurrent scope.\n\nBy default variables are returned with ``${}``, ``@{}`` or ``&{}``\ndecoration based on variable types. Giving a true value (see `Boolean\narguments`) to the optional argument ``no_decoration`` will return\nthe variables without the decoration. This option is new in Robot\nFramework 2.9.\n\nExample:\n| ${example_variable} =         | Set Variable | example value         |\n| ${variables} =                | Get Variables |                      |\n| Dictionary Should Contain Key | ${variables} | \\${example_variable} |\n| Dictionary Should Contain Key | ${variables} | \\${ExampleVariable}  |\n| Set To Dictionary             | ${variables} | \\${name} | value     |\n| Variable Should Not Exist     | \\${name}    |           |           |\n| ${no decoration} =            | Get Variables | no_decoration=Yes |\n| Dictionary Should Contain Key | ${no decoration} | example_variable |"}, {"name": "Import Library", "args": ["name", "*args"], "doc": "Imports a library with the given name and optional arguments.\n\nThis functionality allows dynamic importing of libraries while tests\nare running. That may be necessary, if the library itself is dynamic\nand not yet available when test data is processed. In a normal case,\nlibraries should be imported using the Library setting in the Setting\ntable.\n\nThis keyword supports importing libraries both using library\nnames and physical paths. When paths are used, they must be\ngiven in absolute format or found from\n[http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#pythonpath-jythonpath-and-ironpythonpath|\nsearch path]. Forward slashes can be used as path separators in all\noperating systems.\n\nIt is possible to pass arguments to the imported library and also\nnamed argument syntax works if the library supports it. ``WITH NAME``\nsyntax can be used to give a custom name to the imported library.\n\nExamples:\n| Import Library | MyLibrary |\n| Import Library | ${CURDIR}/../Library.py | arg1 | named=arg2 |\n| Import Library | ${LIBRARIES}/Lib.java | arg | WITH NAME | JavaLib |"}, {"name": "Import Resource", "args": ["path"], "doc": "Imports a resource file with the given path.\n\nResources imported with this keyword are set into the test suite scope\nsimilarly when importing them in the Setting table using the Resource\nsetting.\n\nThe given path must be absolute or found from\n[http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#pythonpath-jythonpath-and-ironpythonpath|\nsearch path]. Forward slashes can be used as path separator regardless\nthe operating system.\n\nExamples:\n| Import Resource | ${CURDIR}/resource.txt |\n| Import Resource | ${CURDIR}/../resources/resource.html |\n| Import Resource | found_from_pythonpath.robot |"}, {"name": "Import Variables", "args": ["path", "*args"], "doc": "Imports a variable file with the given path and optional arguments.\n\nVariables imported with this keyword are set into the test suite scope\nsimilarly when importing them in the Setting table using the Variables\nsetting. These variables override possible existing variables with\nthe same names. This functionality can thus be used to import new\nvariables, for example, for each test in a test suite.\n\nThe given path must be absolute or found from\n[http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#pythonpath-jythonpath-and-ironpythonpath|\nsearch path]. Forward slashes can be used as path separator regardless\nthe operating system.\n\nExamples:\n| Import Variables | ${CURDIR}/variables.py   |      |      |\n| Import Variables | ${CURDIR}/../vars/env.py | arg1 | arg2 |\n| Import Variables | file_from_pythonpath.py  |      |      |"}, {"name": "Keyword Should Exist", "args": ["name", "msg=None"], "doc": "Fails unless the given keyword exists in the current scope.\n\nFails also if there are more than one keywords with the same name.\nWorks both with the short name (e.g. ``Log``) and the full name\n(e.g. ``BuiltIn.Log``).\n\nThe default error message can be overridden with the ``msg`` argument.\n\nSee also `Variable Should Exist`."}, {"name": "Length Should Be", "args": ["item", "length", "msg=None"], "doc": "Verifies that the length of the given item is correct.\n\nThe length of the item is got using the `Get Length` keyword. The\ndefault error message can be overridden with the ``msg`` argument."}, {"name": "Log", "args": ["message", "level=INFO", "html=False", "console=False", "repr=False"], "doc": "Logs the given message with the given level.\n\nValid levels are TRACE, DEBUG, INFO (default), HTML, WARN, and ERROR.\nMessages below the current active log level are ignored. See\n`Set Log Level` keyword and ``--loglevel`` command line option\nfor more details about setting the level.\n\nMessages logged with the WARN or ERROR levels will be automatically\nvisible also in the console and in the Test Execution Errors section\nin the log file.\n\nLogging can be configured using optional ``html``, ``console`` and\n``repr`` arguments. They are off by default, but can be enabled\nby giving them a true value. See `Boolean arguments` section for more\ninformation about true and false values.\n\nIf the ``html`` argument is given a true value, the message will be\nconsidered HTML and special characters such as ``<`` in it are not\nescaped. For example, logging ``<img src=\"image.png\">`` creates an\nimage when ``html`` is true, but otherwise the message is that exact\nstring. An alternative to using the ``html`` argument is using the HTML\npseudo log level. It logs the message as HTML using the INFO level.\n\nIf the ``console`` argument is true, the message will be written to\nthe console where test execution was started from in addition to\nthe log file. This keyword always uses the standard output stream\nand adds a newline after the written message. Use `Log To Console`\ninstead if either of these is undesirable,\n\nIf the ``repr`` argument is true, the given item will be passed through\na custom version of Python's ``pprint.pformat()`` function before\nlogging it. This is useful, for example, when working with strings or\nbytes containing invisible characters, or when working with nested data\nstructures. The custom version differs from the standard one so that it\nomits the ``u`` prefix from Unicode strings and adds ``b`` prefix to\nbyte strings on Python 2.\n\nExamples:\n| Log | Hello, world!        |          |   | # Normal INFO message.   |\n| Log | Warning, world!      | WARN     |   | # Warning.               |\n| Log | <b>Hello</b>, world! | html=yes |   | # INFO message as HTML.  |\n| Log | <b>Hello</b>, world! | HTML     |   | # Same as above.         |\n| Log | <b>Hello</b>, world! | DEBUG    | html=true | # DEBUG as HTML. |\n| Log | Hello, console!   | console=yes | | # Log also to the console. |\n| Log | Hyv\u00e4 \\x00     | repr=yes    | | # Log ``'Hyv\\xe4 \\x00'``. |\n\nSee `Log Many` if you want to log multiple messages in one go, and\n`Log To Console` if you only want to write to the console."}, {"name": "Log Many", "args": ["*messages"], "doc": "Logs the given messages as separate entries using the INFO level.\n\nSupports also logging list and dictionary variable items individually.\n\nExamples:\n| Log Many | Hello   | ${var}  |\n| Log Many | @{list} | &{dict} |\n\nSee `Log` and `Log To Console` keywords if you want to use alternative\nlog levels, use HTML, or log to the console."}, {"name": "Log To Console", "args": ["message", "stream=STDOUT", "no_newline=False"], "doc": "Logs the given message to the console.\n\nBy default uses the standard output stream. Using the standard error\nstream is possibly by giving the ``stream`` argument value ``STDERR``\n(case-insensitive).\n\nBy default appends a newline to the logged message. This can be\ndisabled by giving the ``no_newline`` argument a true value (see\n`Boolean arguments`).\n\nExamples:\n| Log To Console | Hello, console!             |                 |\n| Log To Console | Hello, stderr!              | STDERR          |\n| Log To Console | Message starts here and is  | no_newline=true |\n| Log To Console | continued without newline.  |                 |\n\nThis keyword does not log the message to the normal log file. Use\n`Log` keyword, possibly with argument ``console``, if that is desired."}, {"name": "Log Variables", "args": ["level=INFO"], "doc": "Logs all variables in the current scope with given log level."}, {"name": "No Operation", "args": [], "doc": "Does absolutely nothing."}, {"name": "Pass Execution", "args": ["message", "*tags"], "doc": "Skips rest of the current test, setup, or teardown with PASS status.\n\nThis keyword can be used anywhere in the test data, but the place where\nused affects the behavior:\n\n- When used in any setup or teardown (suite, test or keyword), passes\n  that setup or teardown. Possible keyword teardowns of the started\n  keywords are executed. Does not affect execution or statuses\n  otherwise.\n- When used in a test outside setup or teardown, passes that particular\n  test case. Possible test and keyword teardowns are executed.\n\nPossible continuable failures before this keyword is used, as well as\nfailures in executed teardowns, will fail the execution.\n\nIt is mandatory to give a message explaining why execution was passed.\nBy default the message is considered plain text, but starting it with\n``*HTML*`` allows using HTML formatting.\n\nIt is also possible to modify test tags passing tags after the message\nsimilarly as with `Fail` keyword. Tags starting with a hyphen\n(e.g. ``-regression``) are removed and others added. Tags are modified\nusing `Set Tags` and `Remove Tags` internally, and the semantics\nsetting and removing them are the same as with these keywords.\n\nExamples:\n| Pass Execution | All features available in this version tested. |\n| Pass Execution | Deprecated test. | deprecated | -regression    |\n\nThis keyword is typically wrapped to some other keyword, such as\n`Run Keyword If`, to pass based on a condition. The most common case\ncan be handled also with `Pass Execution If`:\n\n| Run Keyword If    | ${rc} < 0 | Pass Execution | Negative values are cool. |\n| Pass Execution If | ${rc} < 0 | Negative values are cool. |\n\nPassing execution in the middle of a test, setup or teardown should be\nused with care. In the worst case it leads to tests that skip all the\nparts that could actually uncover problems in the tested application.\nIn cases where execution cannot continue do to external factors,\nit is often safer to fail the test case and make it non-critical."}, {"name": "Pass Execution If", "args": ["condition", "message", "*tags"], "doc": "Conditionally skips rest of the current test, setup, or teardown with PASS status.\n\nA wrapper for `Pass Execution` to skip rest of the current test,\nsetup or teardown based the given ``condition``. The condition is\nevaluated similarly as with `Should Be True` keyword, and ``message``\nand ``*tags`` have same semantics as with `Pass Execution`.\n\nExample:\n| :FOR | ${var}            | IN                     | @{VALUES}               |\n|      | Pass Execution If | '${var}' == 'EXPECTED' | Correct value was found |\n|      | Do Something      | ${var}                 |"}, {"name": "Regexp Escape", "args": ["*patterns"], "doc": "Returns each argument string escaped for use as a regular expression.\n\nThis keyword can be used to escape strings to be used with\n`Should Match Regexp` and `Should Not Match Regexp` keywords.\n\nEscaping is done with Python's ``re.escape()`` function.\n\nExamples:\n| ${escaped} = | Regexp Escape | ${original} |\n| @{strings} = | Regexp Escape | @{strings}  |"}, {"name": "Reload Library", "args": ["name_or_instance"], "doc": "Rechecks what keywords the specified library provides.\n\nCan be called explicitly in the test data or by a library itself\nwhen keywords it provides have changed.\n\nThe library can be specified by its name or as the active instance of\nthe library. The latter is especially useful if the library itself\ncalls this keyword as a method.\n\nNew in Robot Framework 2.9."}, {"name": "Remove Tags", "args": ["*tags"], "doc": "Removes given ``tags`` from the current test or all tests in a suite.\n\nTags can be given exactly or using a pattern with ``*``, ``?`` and\n``[chars]`` acting as wildcards. See the `Glob patterns` section\nfor more information.\n\nThis keyword can affect either one test case or all test cases in a\ntest suite similarly as `Set Tags` keyword.\n\nThe current tags are available as a built-in variable ``@{TEST TAGS}``.\n\nExample:\n| Remove Tags | mytag | something-* | ?ython |\n\nSee `Set Tags` if you want to add certain tags and `Fail` if you want\nto fail the test case after setting and/or removing tags."}, {"name": "Repeat Keyword", "args": ["repeat", "name", "*args"], "doc": "Executes the specified keyword multiple times.\n\n``name`` and ``args`` define the keyword that is executed similarly as\nwith `Run Keyword`. ``repeat`` specifies how many times (as a count) or\nhow long time (as a timeout) the keyword should be executed.\n\nIf ``repeat`` is given as count, it specifies how many times the\nkeyword should be executed. ``repeat`` can be given as an integer or\nas a string that can be converted to an integer. If it is a string,\nit can have postfix ``times`` or ``x`` (case and space insensitive)\nto make the expression more explicit.\n\nIf ``repeat`` is given as timeout, it must be in Robot Framework's\ntime format (e.g. ``1 minute``, ``2 min 3 s``). Using a number alone\n(e.g. ``1`` or ``1.5``) does not work in this context.\n\nIf ``repeat`` is zero or negative, the keyword is not executed at\nall. This keyword fails immediately if any of the execution\nrounds fails.\n\nExamples:\n| Repeat Keyword | 5 times   | Go to Previous Page |\n| Repeat Keyword | ${var}    | Some Keyword | arg1 | arg2 |\n| Repeat Keyword | 2 minutes | Some Keyword | arg1 | arg2 |\n\nSpecifying ``repeat`` as a timeout is new in Robot Framework 3.0."}, {"name": "Replace Variables", "args": ["text"], "doc": "Replaces variables in the given text with their current values.\n\nIf the text contains undefined variables, this keyword fails.\nIf the given ``text`` contains only a single variable, its value is\nreturned as-is and it can be any object. Otherwise this keyword\nalways returns a string.\n\nExample:\n\nThe file ``template.txt`` contains ``Hello ${NAME}!`` and variable\n``${NAME}`` has the value ``Robot``.\n\n| ${template} =   | Get File          | ${CURDIR}/template.txt |\n| ${message} =    | Replace Variables | ${template}            |\n| Should Be Equal | ${message}        | Hello Robot!           |"}, {"name": "Return From Keyword", "args": ["*return_values"], "doc": "Returns from the enclosing user keyword.\n\nThis keyword can be used to return from a user keyword with PASS status\nwithout executing it fully. It is also possible to return values\nsimilarly as with the ``[Return]`` setting. For more detailed information\nabout working with the return values, see the User Guide.\n\nThis keyword is typically wrapped to some other keyword, such as\n`Run Keyword If` or `Run Keyword If Test Passed`, to return based\non a condition:\n\n| Run Keyword If | ${rc} < 0 | Return From Keyword |\n| Run Keyword If Test Passed | Return From Keyword |\n\nIt is possible to use this keyword to return from a keyword also inside\na for loop. That, as well as returning values, is demonstrated by the\n`Find Index` keyword in the following somewhat advanced example.\nNotice that it is often a good idea to move this kind of complicated\nlogic into a test library.\n\n| ***** Variables *****\n| @{LIST} =    foo    baz\n|\n| ***** Test Cases *****\n| Example\n|     ${index} =    Find Index    baz    @{LIST}\n|     Should Be Equal    ${index}    ${1}\n|     ${index} =    Find Index    non existing    @{LIST}\n|     Should Be Equal    ${index}    ${-1}\n|\n| ***** Keywords *****\n| Find Index\n|    [Arguments]    ${element}    @{items}\n|    ${index} =    Set Variable    ${0}\n|    :FOR    ${item}    IN    @{items}\n|    \\    Run Keyword If    '${item}' == '${element}'    Return From Keyword    ${index}\n|    \\    ${index} =    Set Variable    ${index + 1}\n|    Return From Keyword    ${-1}    # Also [Return] would work here.\n\nThe most common use case, returning based on an expression, can be\naccomplished directly with `Return From Keyword If`. See also\n`Run Keyword And Return` and `Run Keyword And Return If`."}, {"name": "Return From Keyword If", "args": ["condition", "*return_values"], "doc": "Returns from the enclosing user keyword if ``condition`` is true.\n\nA wrapper for `Return From Keyword` to return based on the given\ncondition. The condition is evaluated using the same semantics as\nwith `Should Be True` keyword.\n\nGiven the same example as in `Return From Keyword`, we can rewrite the\n`Find Index` keyword as follows:\n\n| ***** Keywords *****\n| Find Index\n|    [Arguments]    ${element}    @{items}\n|    ${index} =    Set Variable    ${0}\n|    :FOR    ${item}    IN    @{items}\n|    \\    Return From Keyword If    '${item}' == '${element}'    ${index}\n|    \\    ${index} =    Set Variable    ${index + 1}\n|    Return From Keyword    ${-1}    # Also [Return] would work here.\n\nSee also `Run Keyword And Return` and `Run Keyword And Return If`."}, {"name": "Run Keyword", "args": ["name", "*args"], "doc": "Executes the given keyword with the given arguments.\n\nBecause the name of the keyword to execute is given as an argument, it\ncan be a variable and thus set dynamically, e.g. from a return value of\nanother keyword or from the command line."}, {"name": "Run Keyword And Continue On Failure", "args": ["name", "*args"], "doc": "Runs the keyword and continues execution even if a failure occurs.\n\nThe keyword name and arguments work as with `Run Keyword`.\n\nExample:\n| Run Keyword And Continue On Failure | Fail | This is a stupid example |\n| Log | This keyword is executed |\n\nThe execution is not continued if the failure is caused by invalid syntax,\ntimeout, or fatal exception.\nSince Robot Framework 2.9, variable errors are caught by this keyword."}, {"name": "Run Keyword And Expect Error", "args": ["expected_error", "name", "*args"], "doc": "Runs the keyword and checks that the expected error occurred.\n\nThe keyword to execute and its arguments are specified using ``name``\nand ``*args`` exactly like with `Run Keyword`.\n\nThe expected error must be given in the same format as in Robot\nFramework reports. By default it is interpreted as a glob pattern\nwith ``*``, ``?`` and ``[chars]`` as wildcards, but starting from\nRobot Framework 3.1 that can be changed by using various prefixes\nexplained in the table below. Prefixes are case-sensitive and they\nmust be separated from the actual message with a colon and an\noptional space like ``PREFIX: Message`` or ``PREFIX:Message``.\n\n| = Prefix = | = Explanation = |\n| ``EQUALS`` | Exact match. Especially useful if the error contains glob wildcards. |\n| ``STARTS`` | Error must start with the specified error. |\n| ``REGEXP`` | Regular expression match. |\n| ``GLOB``   | Same as the default behavior. |\n\nSee the `Pattern matching` section for more information about glob\npatterns and regular expressions.\n\nIf the expected error occurs, the error message is returned and it can\nbe further processed or tested if needed. If there is no error, or the\nerror does not match the expected error, this keyword fails.\n\nExamples:\n| Run Keyword And Expect Error | My error            | Keyword | arg |\n| Run Keyword And Expect Error | ValueError: *       | Some Keyword  |\n| Run Keyword And Expect Error | STARTS: ValueError: | Some Keyword  |\n| Run Keyword And Expect Error | EQUALS:No match for '//input[@type=\"text\"]' |\n| ...                          | Find Element | //input[@type=\"text\"] |\n| ${msg} =                     | Run Keyword And Expect Error | * |\n| ...                          | Keyword | arg1 | arg2 |\n| Log To Console | ${msg} |\n\nErrors caused by invalid syntax, timeouts, or fatal exceptions are not\ncaught by this keyword.\nSince Robot Framework 2.9, variable errors are caught by this keyword."}, {"name": "Run Keyword And Ignore Error", "args": ["name", "*args"], "doc": "Runs the given keyword with the given arguments and ignores possible error.\n\nThis keyword returns two values, so that the first is either string\n``PASS`` or ``FAIL``, depending on the status of the executed keyword.\nThe second value is either the return value of the keyword or the\nreceived error message. See `Run Keyword And Return Status` If you are\nonly interested in the execution status.\n\nThe keyword name and arguments work as in `Run Keyword`. See\n`Run Keyword If` for a usage example.\n\nErrors caused by invalid syntax, timeouts, or fatal exceptions are not\ncaught by this keyword. Otherwise this keyword itself never fails.\nSince Robot Framework 2.9, variable errors are caught by this keyword."}, {"name": "Run Keyword And Return", "args": ["name", "*args"], "doc": "Runs the specified keyword and returns from the enclosing user keyword.\n\nThe keyword to execute is defined with ``name`` and ``*args`` exactly\nlike with `Run Keyword`. After running the keyword, returns from the\nenclosing user keyword and passes possible return value from the\nexecuted keyword further. Returning from a keyword has exactly same\nsemantics as with `Return From Keyword`.\n\nExample:\n| `Run Keyword And Return`  | `My Keyword` | arg1 | arg2 |\n| # Above is equivalent to: |\n| ${result} =               | `My Keyword` | arg1 | arg2 |\n| `Return From Keyword`     | ${result}    |      |      |\n\nUse `Run Keyword And Return If` if you want to run keyword and return\nbased on a condition."}, {"name": "Run Keyword And Return If", "args": ["condition", "name", "*args"], "doc": "Runs the specified keyword and returns from the enclosing user keyword.\n\nA wrapper for `Run Keyword And Return` to run and return based on\nthe given ``condition``. The condition is evaluated using the same\nsemantics as with `Should Be True` keyword.\n\nExample:\n| `Run Keyword And Return If` | ${rc} > 0 | `My Keyword` | arg1 | arg2 |\n| # Above is equivalent to:   |\n| `Run Keyword If`            | ${rc} > 0 | `Run Keyword And Return` | `My Keyword ` | arg1 | arg2 |\n\nUse `Return From Keyword If` if you want to return a certain value\nbased on a condition."}, {"name": "Run Keyword And Return Status", "args": ["name", "*args"], "doc": "Runs the given keyword with given arguments and returns the status as a Boolean value.\n\nThis keyword returns Boolean ``True`` if the keyword that is executed\nsucceeds and ``False`` if it fails. This is useful, for example, in\ncombination with `Run Keyword If`. If you are interested in the error\nmessage or return value, use `Run Keyword And Ignore Error` instead.\n\nThe keyword name and arguments work as in `Run Keyword`.\n\nExample:\n| ${passed} = | `Run Keyword And Return Status` | Keyword | args |\n| `Run Keyword If` | ${passed} | Another keyword |\n\nErrors caused by invalid syntax, timeouts, or fatal exceptions are not\ncaught by this keyword. Otherwise this keyword itself never fails."}, {"name": "Run Keyword If", "args": ["condition", "name", "*args"], "doc": "Runs the given keyword with the given arguments, if ``condition`` is true.\n\nThe given ``condition`` is evaluated in Python as explained in\n`Evaluating expressions`, and ``name`` and ``*args`` have same\nsemantics as with `Run Keyword`.\n\nExample, a simple if/else construct:\n| ${status} | ${value} = | `Run Keyword And Ignore Error` | `My Keyword` |\n| `Run Keyword If`     | '${status}' == 'PASS' | `Some Action`    | arg |\n| `Run Keyword Unless` | '${status}' == 'PASS' | `Another Action` |\n\nIn this example, only either `Some Action` or `Another Action` is\nexecuted, based on the status of `My Keyword`. Instead of `Run Keyword\nAnd Ignore Error` you can also use `Run Keyword And Return Status`.\n\nVariables used like ``${variable}``, as in the examples above, are\nreplaced in the expression before evaluation. Variables are also\navailable in the evaluation namespace and can be accessed using special\nsyntax ``$variable``. This is a new feature in Robot Framework 2.9\nand it is explained more thoroughly in `Evaluating expressions`.\n\nExample:\n| `Run Keyword If` | $result is None or $result == 'FAIL' | `Keyword` |\n\nThis keyword supports also optional ELSE and ELSE IF branches. Both\nof them are defined in ``*args`` and must use exactly format ``ELSE``\nor ``ELSE IF``, respectively. ELSE branches must contain first the\nname of the keyword to execute and then its possible arguments. ELSE\nIF branches must first contain a condition, like the first argument\nto this keyword, and then the keyword to execute and its possible\narguments. It is possible to have ELSE branch after ELSE IF and to\nhave multiple ELSE IF branches. Nested `Run Keyword If` usage is not\nsupported when using ELSE and/or ELSE IF branches.\n\nGiven previous example, if/else construct can also be created like this:\n| ${status} | ${value} = | `Run Keyword And Ignore Error` | `My Keyword` |\n| `Run Keyword If` | '${status}' == 'PASS' | `Some Action` | arg | ELSE | `Another Action` |\n\nThe return value of this keyword is the return value of the actually\nexecuted keyword or Python ``None`` if no keyword was executed (i.e.\nif ``condition`` was false). Hence, it is recommended to use ELSE\nand/or ELSE IF branches to conditionally assign return values from\nkeyword to variables (see `Set Variable If` if you need to set fixed\nvalues conditionally). This is illustrated by the example below:\n\n| ${var1} =   | `Run Keyword If` | ${rc} == 0     | `Some keyword returning a value` |\n| ...         | ELSE IF          | 0 < ${rc} < 42 | `Another keyword` |\n| ...         | ELSE IF          | ${rc} < 0      | `Another keyword with args` | ${rc} | arg2 |\n| ...         | ELSE             | `Final keyword to handle abnormal cases` | ${rc} |\n| ${var2} =   | `Run Keyword If` | ${condition}  | `Some keyword` |\n\nIn this example, ${var2} will be set to ``None`` if ${condition} is\nfalse.\n\nNotice that ``ELSE`` and ``ELSE IF`` control words must be used\nexplicitly and thus cannot come from variables. If you need to use\nliteral ``ELSE`` and ``ELSE IF`` strings as arguments, you can escape\nthem with a backslash like ``\\ELSE`` and ``\\ELSE IF``.\n\nPython's [http://docs.python.org/library/os.html|os] and\n[http://docs.python.org/library/sys.html|sys] modules are\nautomatically imported when evaluating the ``condition``.\nAttributes they contain can thus be used in the condition:\n\n| `Run Keyword If` | os.sep == '/' | `Unix Keyword`        |\n| ...              | ELSE IF       | sys.platform.startswith('java') | `Jython Keyword` |\n| ...              | ELSE          | `Windows Keyword`     |"}, {"name": "Run Keyword If All Critical Tests Passed", "args": ["name", "*args"], "doc": "Runs the given keyword with the given arguments, if all critical tests passed.\n\nThis keyword can only be used in suite teardown. Trying to use it in\nany other place will result in an error.\n\nOtherwise, this keyword works exactly like `Run Keyword`, see its\ndocumentation for more details."}, {"name": "Run Keyword If All Tests Passed", "args": ["name", "*args"], "doc": "Runs the given keyword with the given arguments, if all tests passed.\n\nThis keyword can only be used in a suite teardown. Trying to use it\nanywhere else results in an error.\n\nOtherwise, this keyword works exactly like `Run Keyword`, see its\ndocumentation for more details."}, {"name": "Run Keyword If Any Critical Tests Failed", "args": ["name", "*args"], "doc": "Runs the given keyword with the given arguments, if any critical tests failed.\n\nThis keyword can only be used in a suite teardown. Trying to use it\nanywhere else results in an error.\n\nOtherwise, this keyword works exactly like `Run Keyword`, see its\ndocumentation for more details."}, {"name": "Run Keyword If Any Tests Failed", "args": ["name", "*args"], "doc": "Runs the given keyword with the given arguments, if one or more tests failed.\n\nThis keyword can only be used in a suite teardown. Trying to use it\nanywhere else results in an error.\n\nOtherwise, this keyword works exactly like `Run Keyword`, see its\ndocumentation for more details."}, {"name": "Run Keyword If Test Failed", "args": ["name", "*args"], "doc": "Runs the given keyword with the given arguments, if the test failed.\n\nThis keyword can only be used in a test teardown. Trying to use it\nanywhere else results in an error.\n\nOtherwise, this keyword works exactly like `Run Keyword`, see its\ndocumentation for more details.\n\nPrior to Robot Framework 2.9 failures in test teardown itself were\nnot detected by this keyword."}, {"name": "Run Keyword If Test Passed", "args": ["name", "*args"], "doc": "Runs the given keyword with the given arguments, if the test passed.\n\nThis keyword can only be used in a test teardown. Trying to use it\nanywhere else results in an error.\n\nOtherwise, this keyword works exactly like `Run Keyword`, see its\ndocumentation for more details.\n\nPrior to Robot Framework 2.9 failures in test teardown itself were\nnot detected by this keyword."}, {"name": "Run Keyword If Timeout Occurred", "args": ["name", "*args"], "doc": "Runs the given keyword if either a test or a keyword timeout has occurred.\n\nThis keyword can only be used in a test teardown. Trying to use it\nanywhere else results in an error.\n\nOtherwise, this keyword works exactly like `Run Keyword`, see its\ndocumentation for more details."}, {"name": "Run Keyword Unless", "args": ["condition", "name", "*args"], "doc": "Runs the given keyword with the given arguments if ``condition`` is false.\n\nSee `Run Keyword If` for more information and an example. Notice that\nthis keyword does not support ``ELSE`` or ``ELSE IF`` branches like\n`Run Keyword If` does, though."}, {"name": "Run Keywords", "args": ["*keywords"], "doc": "Executes all the given keywords in a sequence.\n\nThis keyword is mainly useful in setups and teardowns when they need\nto take care of multiple actions and creating a new higher level user\nkeyword would be an overkill.\n\nBy default all arguments are expected to be keywords to be executed.\n\nExamples:\n| `Run Keywords` | `Initialize database` | `Start servers` | `Clear logs` |\n| `Run Keywords` | ${KW 1} | ${KW 2} |\n| `Run Keywords` | @{KEYWORDS} |\n\nKeywords can also be run with arguments using upper case ``AND`` as\na separator between keywords. The keywords are executed so that the\nfirst argument is the first keyword and proceeding arguments until\nthe first ``AND`` are arguments to it. First argument after the first\n``AND`` is the second keyword and proceeding arguments until the next\n``AND`` are its arguments. And so on.\n\nExamples:\n| `Run Keywords` | `Initialize database` | db1 | AND | `Start servers` | server1 | server2 |\n| `Run Keywords` | `Initialize database` | ${DB NAME} | AND | `Start servers` | @{SERVERS} | AND | `Clear logs` |\n| `Run Keywords` | ${KW} | AND | @{KW WITH ARGS} |\n\nNotice that the ``AND`` control argument must be used explicitly and\ncannot itself come from a variable. If you need to use literal ``AND``\nstring as argument, you can either use variables or escape it with\na backslash like ``\\AND``."}, {"name": "Set Global Variable", "args": ["name", "*values"], "doc": "Makes a variable available globally in all tests and suites.\n\nVariables set with this keyword are globally available in all\nsubsequent test suites, test cases and user keywords. Also variables\nin variable tables are overridden. Variables assigned locally based\non keyword return values or by using `Set Test Variable` and\n`Set Suite Variable` override these variables in that scope, but\nthe global value is not changed in those cases.\n\nIn practice setting variables with this keyword has the same effect\nas using command line options ``--variable`` and ``--variablefile``.\nBecause this keyword can change variables everywhere, it should be\nused with care.\n\nSee `Set Suite Variable` for more information and examples."}, {"name": "Set Library Search Order", "args": ["*search_order"], "doc": "Sets the resolution order to use when a name matches multiple keywords.\n\nThe library search order is used to resolve conflicts when a keyword\nname in the test data matches multiple keywords. The first library\n(or resource, see below) containing the keyword is selected and that\nkeyword implementation used. If the keyword is not found from any library\n(or resource), test executing fails the same way as when the search\norder is not set.\n\nWhen this keyword is used, there is no need to use the long\n``LibraryName.Keyword Name`` notation.  For example, instead of\nhaving\n\n| MyLibrary.Keyword | arg |\n| MyLibrary.Another Keyword |\n| MyLibrary.Keyword | xxx |\n\nyou can have\n\n| Set Library Search Order | MyLibrary |\n| Keyword | arg |\n| Another Keyword |\n| Keyword | xxx |\n\nThis keyword can be used also to set the order of keywords in different\nresource files. In this case resource names must be given without paths\nor extensions like:\n\n| Set Library Search Order | resource | another_resource |\n\n*NOTE:*\n- The search order is valid only in the suite where this keywords is used.\n- Keywords in resources always have higher priority than\n  keywords in libraries regardless the search order.\n- The old order is returned and can be used to reset the search order later.\n- Library and resource names in the search order are both case and space\n  insensitive."}, {"name": "Set Log Level", "args": ["level"], "doc": "Sets the log threshold to the specified level and returns the old level.\n\nMessages below the level will not logged. The default logging level is\nINFO, but it can be overridden with the command line option\n``--loglevel``.\n\nThe available levels: TRACE, DEBUG, INFO (default), WARN, ERROR and NONE (no\nlogging)."}, {"name": "Set Suite Documentation", "args": ["doc", "append=False", "top=False"], "doc": "Sets documentation for the current test suite.\n\nBy default the possible existing documentation is overwritten, but\nthis can be changed using the optional ``append`` argument similarly\nas with `Set Test Message` keyword.\n\nThis keyword sets the documentation of the current suite by default.\nIf the optional ``top`` argument is given a true value (see `Boolean\narguments`), the documentation of the top level suite is altered\ninstead.\n\nThe documentation of the current suite is available as a built-in\nvariable ``${SUITE DOCUMENTATION}``."}, {"name": "Set Suite Metadata", "args": ["name", "value", "append=False", "top=False"], "doc": "Sets metadata for the current test suite.\n\nBy default possible existing metadata values are overwritten, but\nthis can be changed using the optional ``append`` argument similarly\nas with `Set Test Message` keyword.\n\nThis keyword sets the metadata of the current suite by default.\nIf the optional ``top`` argument is given a true value (see `Boolean\narguments`), the metadata of the top level suite is altered instead.\n\nThe metadata of the current suite is available as a built-in variable\n``${SUITE METADATA}`` in a Python dictionary. Notice that modifying this\nvariable directly has no effect on the actual metadata the suite has."}, {"name": "Set Suite Variable", "args": ["name", "*values"], "doc": "Makes a variable available everywhere within the scope of the current suite.\n\nVariables set with this keyword are available everywhere within the\nscope of the currently executed test suite. Setting variables with this\nkeyword thus has the same effect as creating them using the Variable\ntable in the test data file or importing them from variable files.\n\nPossible child test suites do not see variables set with this keyword\nby default. Starting from Robot Framework 2.9, that can be controlled\nby using ``children=<option>`` as the last argument. If the specified\n``<option>`` is a non-empty string or any other value considered true\nin Python, the variable is set also to the child suites. Parent and\nsibling suites will never see variables set with this keyword.\n\nThe name of the variable can be given either as a normal variable name\n(e.g. ``${NAME}``) or in escaped format as ``\\${NAME}`` or ``$NAME``.\nVariable value can be given using the same syntax as when variables\nare created in the Variable table.\n\nIf a variable already exists within the new scope, its value will be\noverwritten. Otherwise a new variable is created. If a variable already\nexists within the current scope, the value can be left empty and the\nvariable within the new scope gets the value within the current scope.\n\nExamples:\n| Set Suite Variable | ${SCALAR} | Hello, world! |\n| Set Suite Variable | ${SCALAR} | Hello, world! | children=true |\n| Set Suite Variable | @{LIST}   | First item    | Second item   |\n| Set Suite Variable | &{DICT}   | key=value     | foo=bar       |\n| ${ID} =            | Get ID    |\n| Set Suite Variable | ${ID}     |\n\nTo override an existing value with an empty value, use built-in\nvariables ``${EMPTY}``, ``@{EMPTY}`` or ``&{EMPTY}``:\n\n| Set Suite Variable | ${SCALAR} | ${EMPTY} |\n| Set Suite Variable | @{LIST}   | @{EMPTY} |\n| Set Suite Variable | &{DICT}   | &{EMPTY} |\n\n*NOTE:* If the variable has value which itself is a variable (escaped\nor not), you must always use the escaped format to set the variable:\n\nExample:\n| ${NAME} =          | Set Variable | \\${var} |\n| Set Suite Variable | ${NAME}      | value | # Sets variable ${var}  |\n| Set Suite Variable | \\${NAME}    | value | # Sets variable ${NAME} |\n\nThis limitation applies also to `Set Test Variable`, `Set Global\nVariable`, `Variable Should Exist`, `Variable Should Not Exist` and\n`Get Variable Value` keywords."}, {"name": "Set Tags", "args": ["*tags"], "doc": "Adds given ``tags`` for the current test or all tests in a suite.\n\nWhen this keyword is used inside a test case, that test gets\nthe specified tags and other tests are not affected.\n\nIf this keyword is used in a suite setup, all test cases in\nthat suite, recursively, gets the given tags. It is a failure\nto use this keyword in a suite teardown.\n\nThe current tags are available as a built-in variable ``@{TEST TAGS}``.\n\nSee `Remove Tags` if you want to remove certain tags and `Fail` if\nyou want to fail the test case after setting and/or removing tags."}, {"name": "Set Task Variable", "args": ["name", "*values"], "doc": "Makes a variable available everywhere within the scope of the current task.\n\nThis is an alias for `Set Test Variable` that is more applicable when\ncreating tasks, not tests. New in RF 3.1."}, {"name": "Set Test Documentation", "args": ["doc", "append=False"], "doc": "Sets documentation for the current test case.\n\nBy default the possible existing documentation is overwritten, but\nthis can be changed using the optional ``append`` argument similarly\nas with `Set Test Message` keyword.\n\nThe current test documentation is available as a built-in variable\n``${TEST DOCUMENTATION}``. This keyword can not be used in suite\nsetup or suite teardown."}, {"name": "Set Test Message", "args": ["message", "append=False"], "doc": "Sets message for the current test case.\n\nIf the optional ``append`` argument is given a true value (see `Boolean\narguments`), the given ``message`` is added after the possible earlier\nmessage by joining the messages with a space.\n\nIn test teardown this keyword can alter the possible failure message,\nbut otherwise failures override messages set by this keyword. Notice\nthat in teardown the message is available as a built-in variable\n``${TEST MESSAGE}``.\n\nIt is possible to use HTML format in the message by starting the message\nwith ``*HTML*``.\n\nExamples:\n| Set Test Message | My message           |                          |\n| Set Test Message | is continued.        | append=yes               |\n| Should Be Equal  | ${TEST MESSAGE}      | My message is continued. |\n| Set Test Message | `*`HTML`*` <b>Hello!</b> |                      |\n\nThis keyword can not be used in suite setup or suite teardown."}, {"name": "Set Test Variable", "args": ["name", "*values"], "doc": "Makes a variable available everywhere within the scope of the current test.\n\nVariables set with this keyword are available everywhere within the\nscope of the currently executed test case. For example, if you set a\nvariable in a user keyword, it is available both in the test case level\nand also in all other user keywords used in the current test. Other\ntest cases will not see variables set with this keyword.\n\nSee `Set Suite Variable` for more information and examples."}, {"name": "Set Variable", "args": ["*values"], "doc": "Returns the given values which can then be assigned to a variables.\n\nThis keyword is mainly used for setting scalar variables.\nAdditionally it can be used for converting a scalar variable\ncontaining a list to a list variable or to multiple scalar variables.\nIt is recommended to use `Create List` when creating new lists.\n\nExamples:\n| ${hi} =   | Set Variable | Hello, world! |\n| ${hi2} =  | Set Variable | I said: ${hi} |\n| ${var1}   | ${var2} =    | Set Variable | Hello | world |\n| @{list} = | Set Variable | ${list with some items} |\n| ${item1}  | ${item2} =   | Set Variable  | ${list with 2 items} |\n\nVariables created with this keyword are available only in the\nscope where they are created. See `Set Global Variable`,\n`Set Test Variable` and `Set Suite Variable` for information on how to\nset variables so that they are available also in a larger scope."}, {"name": "Set Variable If", "args": ["condition", "*values"], "doc": "Sets variable based on the given condition.\n\nThe basic usage is giving a condition and two values. The\ngiven condition is first evaluated the same way as with the\n`Should Be True` keyword. If the condition is true, then the\nfirst value is returned, and otherwise the second value is\nreturned. The second value can also be omitted, in which case\nit has a default value None. This usage is illustrated in the\nexamples below, where ``${rc}`` is assumed to be zero.\n\n| ${var1} = | Set Variable If | ${rc} == 0 | zero     | nonzero |\n| ${var2} = | Set Variable If | ${rc} > 0  | value1   | value2  |\n| ${var3} = | Set Variable If | ${rc} > 0  | whatever |         |\n=>\n| ${var1} = 'zero'\n| ${var2} = 'value2'\n| ${var3} = None\n\nIt is also possible to have 'else if' support by replacing the\nsecond value with another condition, and having two new values\nafter it. If the first condition is not true, the second is\nevaluated and one of the values after it is returned based on\nits truth value. This can be continued by adding more\nconditions without a limit.\n\n| ${var} = | Set Variable If | ${rc} == 0        | zero           |\n| ...      | ${rc} > 0       | greater than zero | less then zero |\n|          |\n| ${var} = | Set Variable If |\n| ...      | ${rc} == 0      | zero              |\n| ...      | ${rc} == 1      | one               |\n| ...      | ${rc} == 2      | two               |\n| ...      | ${rc} > 2       | greater than two  |\n| ...      | ${rc} < 0       | less than zero    |\n\nUse `Get Variable Value` if you need to set variables\ndynamically based on whether a variable exist or not."}, {"name": "Should Be Empty", "args": ["item", "msg=None"], "doc": "Verifies that the given item is empty.\n\nThe length of the item is got using the `Get Length` keyword. The\ndefault error message can be overridden with the ``msg`` argument."}, {"name": "Should Be Equal", "args": ["first", "second", "msg=None", "values=True", "ignore_case=False"], "doc": "Fails if the given objects are unequal.\n\nOptional ``msg`` and ``values`` arguments specify how to construct\nthe error message if this keyword fails:\n\n- If ``msg`` is not given, the error message is ``<first> != <second>``.\n- If ``msg`` is given and ``values`` gets a true value (default),\n  the error message is ``<msg>: <first> != <second>``.\n- If ``msg`` is given and ``values`` gets a false value, the error\n  message is simply ``<msg>``. See `Boolean arguments` for more details\n  about using false values.\n\nIf ``ignore_case`` is given a true value (see `Boolean arguments`) and\narguments are strings, it indicates that comparison should be\ncase-insensitive. New option in Robot Framework 3.0.1.\n\nIf both arguments are multiline strings, the comparison is done using\n`multiline string comparisons`.\n\nExamples:\n| Should Be Equal | ${x} | expected |\n| Should Be Equal | ${x} | expected | Custom error message |\n| Should Be Equal | ${x} | expected | Custom message | values=False |\n| Should Be Equal | ${x} | expected | ignore_case=True |"}, {"name": "Should Be Equal As Integers", "args": ["first", "second", "msg=None", "values=True", "base=None"], "doc": "Fails if objects are unequal after converting them to integers.\n\nSee `Convert To Integer` for information how to convert integers from\nother bases than 10 using ``base`` argument or ``0b/0o/0x`` prefixes.\n\nSee `Should Be Equal` for an explanation on how to override the default\nerror message with ``msg`` and ``values``.\n\nExamples:\n| Should Be Equal As Integers | 42   | ${42} | Error message |\n| Should Be Equal As Integers | ABCD | abcd  | base=16 |\n| Should Be Equal As Integers | 0b1011 | 11  |"}, {"name": "Should Be Equal As Numbers", "args": ["first", "second", "msg=None", "values=True", "precision=6"], "doc": "Fails if objects are unequal after converting them to real numbers.\n\nThe conversion is done with `Convert To Number` keyword using the\ngiven ``precision``.\n\nExamples:\n| Should Be Equal As Numbers | ${x} | 1.1 | | # Passes if ${x} is 1.1 |\n| Should Be Equal As Numbers | 1.123 | 1.1 | precision=1  | # Passes |\n| Should Be Equal As Numbers | 1.123 | 1.4 | precision=0  | # Passes |\n| Should Be Equal As Numbers | 112.3 | 75  | precision=-2 | # Passes |\n\nAs discussed in the documentation of `Convert To Number`, machines\ngenerally cannot store floating point numbers accurately. Because of\nthis limitation, comparing floats for equality is problematic and\na correct approach to use depends on the context. This keyword uses\na very naive approach of rounding the numbers before comparing them,\nwhich is both prone to rounding errors and does not work very well if\nnumbers are really big or small. For more information about comparing\nfloats, and ideas on how to implement your own context specific\ncomparison algorithm, see\nhttp://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/.\n\nIf you want to avoid possible problems with floating point numbers,\nyou can implement custom keywords using Python's\n[http://docs.python.org/library/decimal.html|decimal] or\n[http://docs.python.org/library/fractions.html|fractions] modules.\n\nSee `Should Not Be Equal As Numbers` for a negative version of this\nkeyword and `Should Be Equal` for an explanation on how to override\nthe default error message with ``msg`` and ``values``."}, {"name": "Should Be Equal As Strings", "args": ["first", "second", "msg=None", "values=True", "ignore_case=False"], "doc": "Fails if objects are unequal after converting them to strings.\n\nSee `Should Be Equal` for an explanation on how to override the default\nerror message with ``msg`` and ``values``.\n\nIf ``ignore_case`` is given a true value (see `Boolean arguments`), it\nindicates that comparison should be case-insensitive. New option in\nRobot Framework 3.0.1.\n\nIf both arguments are multiline strings, the comparison is done using\n`multiline string comparisons`."}, {"name": "Should Be True", "args": ["condition", "msg=None"], "doc": "Fails if the given condition is not true.\n\nIf ``condition`` is a string (e.g. ``${rc} < 10``), it is evaluated as\na Python expression as explained in `Evaluating expressions` and the\nkeyword status is decided based on the result. If a non-string item is\ngiven, the status is got directly from its\n[http://docs.python.org/library/stdtypes.html#truth|truth value].\n\nThe default error message (``<condition> should be true``) is not very\ninformative, but it can be overridden with the ``msg`` argument.\n\nExamples:\n| Should Be True | ${rc} < 10            |\n| Should Be True | '${status}' == 'PASS' | # Strings must be quoted |\n| Should Be True | ${number}   | # Passes if ${number} is not zero |\n| Should Be True | ${list}     | # Passes if ${list} is not empty  |\n\nVariables used like ``${variable}``, as in the examples above, are\nreplaced in the expression before evaluation. Variables are also\navailable in the evaluation namespace and can be accessed using special\nsyntax ``$variable``. This is a new feature in Robot Framework 2.9\nand it is explained more thoroughly in `Evaluating expressions`.\n\nExamples:\n| Should Be True | $rc < 10          |\n| Should Be True | $status == 'PASS' | # Expected string must be quoted |\n\n`Should Be True` automatically imports Python's\n[http://docs.python.org/library/os.html|os] and\n[http://docs.python.org/library/sys.html|sys] modules that contain\nseveral useful attributes:\n\n| Should Be True | os.linesep == '\\n'             | # Unixy   |\n| Should Be True | os.linesep == '\\r\\n'          | # Windows |\n| Should Be True | sys.platform == 'darwin'        | # OS X    |\n| Should Be True | sys.platform.startswith('java') | # Jython  |"}, {"name": "Should Contain", "args": ["container", "item", "msg=None", "values=True", "ignore_case=False"], "doc": "Fails if ``container`` does not contain ``item`` one or more times.\n\nWorks with strings, lists, and anything that supports Python's ``in``\noperator.\n\nSee `Should Be Equal` for an explanation on how to override the default\nerror message with arguments ``msg`` and ``values``.\n\nIf ``ignore_case`` is given a true value (see `Boolean arguments`) and\ncompared items are strings, it indicates that comparison should be\ncase-insensitive. If the ``container`` is a list-like object, string\nitems in it are compared case-insensitively. New option in Robot\nFramework 3.0.1.\n\nExamples:\n| Should Contain | ${output}    | PASS  |\n| Should Contain | ${some list} | value | msg=Failure! | values=False |\n| Should Contain | ${some list} | value | ignore_case=True |"}, {"name": "Should Contain Any", "args": ["container", "*items", "**configuration"], "doc": "Fails if ``container`` does not contain any of the ``*items``.\n\nWorks with strings, lists, and anything that supports Python's ``in``\noperator.\n\nSupports additional configuration parameters ``msg``, ``values``\nand ``ignore_case``, which have exactly the same semantics as arguments\nwith same names have with `Should Contain`. These arguments must\nalways be given using ``name=value`` syntax after all ``items``.\n\nNote that possible equal signs in ``items`` must be escaped with\na backslash (e.g. ``foo\\=bar``) to avoid them to be passed in\nas ``**configuration``.\n\nExamples:\n| Should Contain Any | ${string} | substring 1 | substring 2 |\n| Should Contain Any | ${list}   | item 1 | item 2 | item 3 |\n| Should Contain Any | ${list}   | item 1 | item 2 | item 3 | ignore_case=True |\n| Should Contain Any | ${list}   | @{items} | msg=Custom message | values=False |\n\nNew in Robot Framework 3.0.1."}, {"name": "Should Contain X Times", "args": ["item1", "item2", "count", "msg=None", "ignore_case=False"], "doc": "Fails if ``item1`` does not contain ``item2`` ``count`` times.\n\nWorks with strings, lists and all objects that `Get Count` works\nwith. The default error message can be overridden with ``msg`` and\nthe actual count is always logged.\n\nIf ``ignore_case`` is given a true value (see `Boolean arguments`) and\ncompared items are strings, it indicates that comparison should be\ncase-insensitive. If the ``item1`` is a list-like object, string\nitems in it are compared case-insensitively. New option in Robot\nFramework 3.0.1.\n\nExamples:\n| Should Contain X Times | ${output}    | hello | 2 |\n| Should Contain X Times | ${some list} | value | 3 | ignore_case=True |"}, {"name": "Should End With", "args": ["str1", "str2", "msg=None", "values=True", "ignore_case=False"], "doc": "Fails if the string ``str1`` does not end with the string ``str2``.\n\nSee `Should Be Equal` for an explanation on how to override the default\nerror message with ``msg`` and ``values``, as well as for semantics\nof the ``ignore_case`` option."}, {"name": "Should Match", "args": ["string", "pattern", "msg=None", "values=True", "ignore_case=False"], "doc": "Fails if the given ``string`` does not match the given ``pattern``.\n\nPattern matching is similar as matching files in a shell with\n``*``, ``?`` and ``[chars]`` acting as wildcards. See the\n`Glob patterns` section for more information.\n\nSee `Should Be Equal` for an explanation on how to override the default\nerror message with ``msg`` and ``values``, as well as for semantics\nof the ``ignore_case`` option."}, {"name": "Should Match Regexp", "args": ["string", "pattern", "msg=None", "values=True"], "doc": "Fails if ``string`` does not match ``pattern`` as a regular expression.\n\nSee the `Regular expressions` section for more information about\nregular expressions and how to use then in Robot Framework test data.\n\nNotice that the given pattern does not need to match the whole string.\nFor example, the pattern ``ello`` matches the string ``Hello world!``.\nIf a full match is needed, the ``^`` and ``$`` characters can be used\nto denote the beginning and end of the string, respectively.\nFor example, ``^ello$`` only matches the exact string ``ello``.\n\nPossible flags altering how the expression is parsed (e.g.\n``re.IGNORECASE``, ``re.MULTILINE``) must be embedded to the\npattern like ``(?im)pattern``. The most useful flags are ``i``\n(case-insensitive), ``m`` (multiline mode), ``s`` (dotall mode)\nand ``x`` (verbose).\n\nIf this keyword passes, it returns the portion of the string that\nmatched the pattern. Additionally, the possible captured groups are\nreturned.\n\nSee the `Should Be Equal` keyword for an explanation on how to override\nthe default error message with the ``msg`` and ``values`` arguments.\n\nExamples:\n| Should Match Regexp | ${output} | \\\\d{6}   | # Output contains six numbers  |\n| Should Match Regexp | ${output} | ^\\\\d{6}$ | # Six numbers and nothing more |\n| ${ret} = | Should Match Regexp | Foo: 42 | (?i)foo: \\\\d+ |\n| ${match} | ${group1} | ${group2} = |\n| ...      | Should Match Regexp | Bar: 43 | (Foo|Bar): (\\\\d+) |\n=>\n| ${ret} = 'Foo: 42'\n| ${match} = 'Bar: 43'\n| ${group1} = 'Bar'\n| ${group2} = '43'"}, {"name": "Should Not Be Empty", "args": ["item", "msg=None"], "doc": "Verifies that the given item is not empty.\n\nThe length of the item is got using the `Get Length` keyword. The\ndefault error message can be overridden with the ``msg`` argument."}, {"name": "Should Not Be Equal", "args": ["first", "second", "msg=None", "values=True", "ignore_case=False"], "doc": "Fails if the given objects are equal.\n\nSee `Should Be Equal` for an explanation on how to override the default\nerror message with ``msg`` and ``values``.\n\nIf ``ignore_case`` is given a true value (see `Boolean arguments`) and\nboth arguments are strings, it indicates that comparison should be\ncase-insensitive. New option in Robot Framework 3.0.1."}, {"name": "Should Not Be Equal As Integers", "args": ["first", "second", "msg=None", "values=True", "base=None"], "doc": "Fails if objects are equal after converting them to integers.\n\nSee `Convert To Integer` for information how to convert integers from\nother bases than 10 using ``base`` argument or ``0b/0o/0x`` prefixes.\n\nSee `Should Be Equal` for an explanation on how to override the default\nerror message with ``msg`` and ``values``.\n\nSee `Should Be Equal As Integers` for some usage examples."}, {"name": "Should Not Be Equal As Numbers", "args": ["first", "second", "msg=None", "values=True", "precision=6"], "doc": "Fails if objects are equal after converting them to real numbers.\n\nThe conversion is done with `Convert To Number` keyword using the\ngiven ``precision``.\n\nSee `Should Be Equal As Numbers` for examples on how to use\n``precision`` and why it does not always work as expected. See also\n`Should Be Equal` for an explanation on how to override the default\nerror message with ``msg`` and ``values``."}, {"name": "Should Not Be Equal As Strings", "args": ["first", "second", "msg=None", "values=True", "ignore_case=False"], "doc": "Fails if objects are equal after converting them to strings.\n\nIf ``ignore_case`` is given a true value (see `Boolean arguments`), it\nindicates that comparison should be case-insensitive. New option in\nRobot Framework 3.0.1.\n\nSee `Should Be Equal` for an explanation on how to override the default\nerror message with ``msg`` and ``values``."}, {"name": "Should Not Be True", "args": ["condition", "msg=None"], "doc": "Fails if the given condition is true.\n\nSee `Should Be True` for details about how ``condition`` is evaluated\nand how ``msg`` can be used to override the default error message."}, {"name": "Should Not Contain", "args": ["container", "item", "msg=None", "values=True", "ignore_case=False"], "doc": "Fails if ``container`` contains ``item`` one or more times.\n\nWorks with strings, lists, and anything that supports Python's ``in``\noperator.\n\nSee `Should Be Equal` for an explanation on how to override the default\nerror message with arguments ``msg`` and ``values``. ``ignore_case``\nhas exactly the same semantics as with `Should Contain`.\n\nExamples:\n| Should Not Contain | ${some list} | value  |\n| Should Not Contain | ${output}    | FAILED | ignore_case=True |"}, {"name": "Should Not Contain Any", "args": ["container", "*items", "**configuration"], "doc": "Fails if ``container`` contains one or more of the ``*items``.\n\nWorks with strings, lists, and anything that supports Python's ``in``\noperator.\n\nSupports additional configuration parameters ``msg``, ``values``\nand ``ignore_case``, which have exactly the same semantics as arguments\nwith same names have with `Should Contain`. These arguments must\nalways be given using ``name=value`` syntax after all ``items``.\n\nNote that possible equal signs in ``items`` must be escaped with\na backslash (e.g. ``foo\\=bar``) to avoid them to be passed in\nas ``**configuration``.\n\nExamples:\n| Should Not Contain Any | ${string} | substring 1 | substring 2 |\n| Should Not Contain Any | ${list}   | item 1 | item 2 | item 3 |\n| Should Not Contain Any | ${list}   | item 1 | item 2 | item 3 | ignore_case=True |\n| Should Not Contain Any | ${list}   | @{items} | msg=Custom message | values=False |\n\nNew in Robot Framework 3.0.1."}, {"name": "Should Not End With", "args": ["str1", "str2", "msg=None", "values=True", "ignore_case=False"], "doc": "Fails if the string ``str1`` ends with the string ``str2``.\n\nSee `Should Be Equal` for an explanation on how to override the default\nerror message with ``msg`` and ``values``, as well as for semantics\nof the ``ignore_case`` option."}, {"name": "Should Not Match", "args": ["string", "pattern", "msg=None", "values=True", "ignore_case=False"], "doc": "Fails if the given ``string`` matches the given ``pattern``.\n\nPattern matching is similar as matching files in a shell with\n``*``, ``?`` and ``[chars]`` acting as wildcards. See the\n`Glob patterns` section for more information.\n\nSee `Should Be Equal` for an explanation on how to override the default\nerror message with ``msg`` and ``values``, as well as for semantics\nof the ``ignore_case`` option."}, {"name": "Should Not Match Regexp", "args": ["string", "pattern", "msg=None", "values=True"], "doc": "Fails if ``string`` matches ``pattern`` as a regular expression.\n\nSee `Should Match Regexp` for more information about arguments."}, {"name": "Should Not Start With", "args": ["str1", "str2", "msg=None", "values=True", "ignore_case=False"], "doc": "Fails if the string ``str1`` starts with the string ``str2``.\n\nSee `Should Be Equal` for an explanation on how to override the default\nerror message with ``msg`` and ``values``, as well as for semantics\nof the ``ignore_case`` option."}, {"name": "Should Start With", "args": ["str1", "str2", "msg=None", "values=True", "ignore_case=False"], "doc": "Fails if the string ``str1`` does not start with the string ``str2``.\n\nSee `Should Be Equal` for an explanation on how to override the default\nerror message with ``msg`` and ``values``, as well as for semantics\nof the ``ignore_case`` option."}, {"name": "Sleep", "args": ["time_", "reason=None"], "doc": "Pauses the test executed for the given time.\n\n``time`` may be either a number or a time string. Time strings are in\na format such as ``1 day 2 hours 3 minutes 4 seconds 5milliseconds`` or\n``1d 2h 3m 4s 5ms``, and they are fully explained in an appendix of\nRobot Framework User Guide. Optional `reason` can be used to explain why\nsleeping is necessary. Both the time slept and the reason are logged.\n\nExamples:\n| Sleep | 42                   |\n| Sleep | 1.5                  |\n| Sleep | 2 minutes 10 seconds |\n| Sleep | 10s                  | Wait for a reply |"}, {"name": "Variable Should Exist", "args": ["name", "msg=None"], "doc": "Fails unless the given variable exists within the current scope.\n\nThe name of the variable can be given either as a normal variable name\n(e.g. ``${NAME}``) or in escaped format (e.g. ``\\${NAME}``). Notice\nthat the former has some limitations explained in `Set Suite Variable`.\n\nThe default error message can be overridden with the ``msg`` argument.\n\nSee also `Variable Should Not Exist` and `Keyword Should Exist`."}, {"name": "Variable Should Not Exist", "args": ["name", "msg=None"], "doc": "Fails if the given variable exists within the current scope.\n\nThe name of the variable can be given either as a normal variable name\n(e.g. ``${NAME}``) or in escaped format (e.g. ``\\${NAME}``). Notice\nthat the former has some limitations explained in `Set Suite Variable`.\n\nThe default error message can be overridden with the ``msg`` argument.\n\nSee also `Variable Should Exist` and `Keyword Should Exist`."}, {"name": "Wait Until Keyword Succeeds", "args": ["retry", "retry_interval", "name", "*args"], "doc": "Runs the specified keyword and retries if it fails.\n\n``name`` and ``args`` define the keyword that is executed similarly\nas with `Run Keyword`. How long to retry running the keyword is\ndefined using ``retry`` argument either as timeout or count.\n``retry_interval`` is the time to wait before trying to run the\nkeyword again after the previous run has failed.\n\nIf ``retry`` is given as timeout, it must be in Robot Framework's\ntime format (e.g. ``1 minute``, ``2 min 3 s``, ``4.5``) that is\nexplained in an appendix of Robot Framework User Guide. If it is\ngiven as count, it must have ``times`` or ``x`` postfix (e.g.\n``5 times``, ``10 x``). ``retry_interval`` must always be given in\nRobot Framework's time format.\n\nIf the keyword does not succeed regardless of retries, this keyword\nfails. If the executed keyword passes, its return value is returned.\n\nExamples:\n| Wait Until Keyword Succeeds | 2 min | 5 sec | My keyword | argument |\n| ${result} = | Wait Until Keyword Succeeds | 3x | 200ms | My keyword |\n\nAll normal failures are caught by this keyword. Errors caused by\ninvalid syntax, test or keyword timeouts, or fatal exceptions (caused\ne.g. by `Fatal Error`) are not caught.\n\nRunning the same keyword multiple times inside this keyword can create\nlots of output and considerably increase the size of the generated\noutput files. It is possible to remove unnecessary keywords from\nthe outputs using ``--RemoveKeywords WUKS`` command line option.\n\nSupport for specifying ``retry`` as a number of times to retry is\na new feature in Robot Framework 2.9.\nSince Robot Framework 2.9, variable errors are caught by this keyword."}]}