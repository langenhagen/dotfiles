{"name":"OperatingSystem","version":"2.7.7","keywords":[{"name":"Append To File","args":"path, content, encoding=UTF-8","doc":"Appends the given contend to the specified file.\n\nIf the file does not exists, this keyword works exactly the same way as Create File With Encoding."},{"name":"Copy Directory","args":"source, destination","doc":"Copies the source directory into the destination.\n\nIf the destination exists, the source is copied under it. Otherwise the destination directory and the possible missing intermediate directories are created."},{"name":"Copy File","args":"source, destination","doc":"Copies the source file into a new destination.\n\n1) If the destination is an existing file, the source file is copied over it.\n\n2) If the destination is an existing directory, the source file is copied into it. A possible file with the same name is overwritten.\n\n3) If the destination does not exist and it ends with a path separator ('/' or '\\\\'), it is considered a directory. That directory is created and a source file copied into it. Possible missing intermediate directories are also created.\n\n4) If the destination does not exist and it does not end with a path separator, it is considered a file. If the path to the file does not exist, it is created."},{"name":"Count Directories In Directory","args":"path, pattern=None","doc":"A wrapper for [Count Items In Directory](#Count Items In Directory) returning only directory count."},{"name":"Count Files In Directory","args":"path, pattern=None","doc":"A wrapper for [Count Items In Directory](#Count Items In Directory) returning only file count."},{"name":"Count Items In Directory","args":"path, pattern=None","doc":"Returns and logs the number of all items in the given directory.\n\nThe argument pattern has the same semantics as in the [List Directory](#List Directory) keyword. The count is returned as an integer, so it must be checked e.g. with the built-in keyword Should Be Equal As Integers."},{"name":"Create Directory","args":"path","doc":"Creates the specified directory.\n\nAlso possible intermediate directories are created. Passes if the directory already exists, and fails if the path points to a regular file."},{"name":"Create File","args":"path, content=, encoding=UTF-8","doc":"Creates a file with the given content and encoding.\n\nIf the directory where to create file does not exist it, and possible intermediate missing directories, are created.\n\nUse [Append To File](#Append To File) if you want to append to an existing file, and use [File Should Not Exist](#File Should Not Exist) if you want to avoid overwriting existing files."},{"name":"Directory Should Be Empty","args":"path, msg=None","doc":"Fails unless the specified directory is empty.\n\nThe default error message can be overridden with the msg argument."},{"name":"Directory Should Exist","args":"path, msg=None","doc":"Fails unless the given path points to an existing directory.\n\nThe path can be given as an exact path or as a glob pattern. The pattern matching syntax is explained in [introduction](#Introduction). The default error message can be overridden with the msg argument."},{"name":"Directory Should Not Be Empty","args":"path, msg=None","doc":"Fails if the specified directory is empty.\n\nThe default error message can be overridden with the msg argument."},{"name":"Directory Should Not Exist","args":"path, msg=None","doc":"Fails if the given path points to an existing file.\n\nThe path can be given as an exact path or as a glob pattern. The pattern matching syntax is explained in [introduction](#Introduction). The default error message can be overridden with the msg argument."},{"name":"Empty Directory","args":"path","doc":"Deletes all the content (incl. subdirectories) from the given directory."},{"name":"Environment Variable Should Be Set","args":"name, msg=None","doc":"Fails if the specified environment variable is not set.\n\nThe default error message can be overridden with the msg argument."},{"name":"Environment Variable Should Not Be Set","args":"name, msg=None","doc":"Fails if the specified environment variable is set.\n\nThe default error message can be overridden with the msg argument."},{"name":"File Should Be Empty","args":"path, msg=None","doc":"Fails unless the specified file is empty.\n\nThe default error message can be overridden with the msg argument."},{"name":"File Should Exist","args":"path, msg=None","doc":"Fails unless the given path points to an existing file.\n\nThe path can be given as an exact path or as a glob pattern. The pattern matching syntax is explained in [introduction](#Introduction). The default error message can be overridden with the msg argument."},{"name":"File Should Not Be Empty","args":"path, msg=None","doc":"Fails if the specified directory is empty.\n\nThe default error message can be overridden with the msg argument."},{"name":"File Should Not Exist","args":"path, msg=None","doc":"Fails if the given path points to an existing file.\n\nThe path can be given as an exact path or as a glob pattern. The pattern matching syntax is explained in [introduction](#Introduction). The default error message can be overridden with the msg argument."},{"name":"Get Binary File","args":"path","doc":"Returns the contents of a specified file.\n\nThis keyword reads the specified file and returns the contents as is. See also [Get File](#Get File).\n\nNew in Robot Framework 2.5.5."},{"name":"Get Environment Variable","args":"name, default=None","doc":"Returns the value of an environment variable with the given name.\n\nIf no such environment variable is set, returns the default value, if given. Otherwise fails the test case.\n\nStarting from Robot Framework 2.7, returned variables are automatically decoded to Unicode using the system encoding.\n\nNote that you can also access environment variables directly using the variable syntax %{ENV\\_VAR\\_NAME}."},{"name":"Get Environment Variables","args":"","doc":"Returns currently available environment variables as a dictionary.\n\nBoth keys and values are decoded to Unicode using the system encoding. Altering the returned dictionary has no effect on the actual environment variables.\n\nNew in Robot Framework 2.7."},{"name":"Get File","args":"path, encoding=UTF-8","doc":"Returns the contents of a specified file.\n\nThis keyword reads the specified file and returns the contents. Line breaks in content are converted to platform independent form. See also [Get Binary File](#Get Binary File).\n\nencoding defines the encoding of the file. By default the value is 'UTF-8', which means that UTF-8 and ASCII-encoded files are read correctly."},{"name":"Get File Size","args":"path","doc":"Returns and logs file size as an integer in bytes"},{"name":"Get Modified Time","args":"path, format=timestamp","doc":"Returns the last modification time of a file or directory.\n\nHow time is returned is determined based on the given format string as follows. Note that all checks are case-insensitive. Returned time is also automatically logged.\n\n1) If format contains the word 'epoch', the time is returned in seconds after the UNIX epoch. The return value is always an integer.\n\n2) If format contains any of the words 'year', 'month', 'day', 'hour', 'min' or 'sec', only the selected parts are returned. The order of the returned parts is always the one in the previous sentence and the order of the words in format is not significant. The parts are returned as zero-padded strings (e.g. May -> '05').\n\n3) Otherwise, and by default, the time is returned as a timestamp string in the format '2006-02-24 15:08:31'.\n\nExamples (when the modified time of the ${CURDIR} is 2006-03-29 15:06:21):\n\n```\n${time} =  Get Modified Time  ${CURDIR}    \n${secs} =  Get Modified Time  ${CURDIR}  epoch  \n${year} =  Get Modified Time  ${CURDIR}  return year  \n${y}  ${d} =  Get Modified Time  ${CURDIR}  year,day\n@{time} =  Get Modified Time  ${CURDIR}  year,month,day,hour,min,sec  \n```\n\n\\=>\n\n*   ${time} = '2006-03-29 15:06:21'\n*   ${secs} = 1143637581\n*   ${year} = '2006'\n*   ${y} = '2006' & ${d} = '29'\n*   @{time} = \\['2006', '03', '29', '15', '06', '21'\\]"},{"name":"Grep File","args":"path, pattern, encoding=UTF-8","doc":"Returns the lines of the specified file that match the pattern.\n\nThis keyword reads a file from the file system using the defined path and encoding similarly as [Get File](#Get File). A difference is that only the lines that match the given pattern are returned. Lines are returned as a single string catenated back together with newlines and the number of matched lines is automatically logged. Possible trailing newline is never returned.\n\nA line matches if it contains the pattern anywhere in it and it **does not need to match the pattern fully**. The pattern matching syntax is explained in [introduction](#Introduction), and in this case matching is case-sensitive.\n\nExamples:\n\n```\n${errors} =  Grep File  /var/log/myapp.log  ERROR\n${ret} =  Grep File  ${CURDIR}/file.txt  [Ww]ildc??d ex*ple\n```\n\nIf more complex pattern matching is needed, it is possible to use [Get File](#Get File) in combination with String library keywords like Get Lines Matching Regexp."},{"name":"Join Path","args":"base, *parts","doc":"Joins the given path part(s) to the given base path.\n\nThe path separator ('/' or '\\\\') is inserted when needed and the possible absolute paths handled as expected. The resulted path is also normalized.\n\nExamples:\n\n```\n${path} =  Join Path  my  path    \n${p2} =  Join Path  my/  path/    \n${p3} =  Join Path  my  path  my  file.txt\n${p4} =  Join Path  my  /path    \n${p5} =  Join Path  /my/path/  ..  path2  \n```\n\n\\=>\n\n*   ${path} = 'my/path'\n*   ${p2} = 'my/path'\n*   ${p3} = 'my/path/my/file.txt'\n*   ${p4} = '/path'\n*   ${p5} = '/my/path2'"},{"name":"Join Paths","args":"base, *paths","doc":"Joins given paths with base and returns resulted paths.\n\nSee [Join Path](#Join Path) for more information.\n\nExamples:\n\n```\n@{p1} =  Join Path  base  example  other  \n@{p2} =  Join Path  /my/base  /example  other  \n@{p3} =  Join Path  my/base  example/path/  other  one/more\n```\n\n\\=>\n\n*   @{p1} = \\['base/example', 'base/other'\\]\n*   @{p2} = \\['/example', '/my/base/other'\\]\n*   @{p3} = \\['my/base/example/path', 'my/base/other', 'my/base/one/more'\\]"},{"name":"List Directories In Directory","args":"path, pattern=None, absolute=False","doc":"A wrapper for [List Directory](#List Directory) that returns only directories."},{"name":"List Directory","args":"path, pattern=None, absolute=False","doc":"Returns and logs items in a directory, optionally filtered with pattern.\n\nFile and directory names are returned in case-sensitive alphabetical order, e.g. \\['A Name', 'Second', 'a lower case name', 'one more'\\]. Implicit directories '.' and '..' are not returned. The returned items are automatically logged.\n\nBy default, the file and directory names are returned relative to the given path (e.g. 'file.txt'). If you want them be returned in the absolute format (e.g. '/home/robot/file.txt'), set the absolute argument to any non-empty string.\n\nIf pattern is given, only items matching it are returned. The pattern matching syntax is explained in [introduction](#Introduction), and in this case matching is case-sensitive.\n\nExamples (using also other [List Directory](#List Directory) variants):\n\n```\n@{items} =  List Directory  ${TEMPDIR}    \n@{files} =  List Files In Directory  /tmp  *.txt  absolute\n${count} =  Count Files In Directory  ${CURDIR}  ???  \n```"},{"name":"List Files In Directory","args":"path, pattern=None, absolute=False","doc":"A wrapper for [List Directory](#List Directory) that returns only files."},{"name":"Log Environment Variables","args":"level=INFO","doc":"Logs all environment variables using the given log level.\n\nEnvironment variables are also returned the same way as with [Get Environment Variables](#Get Environment Variables) keyword.\n\nNew in Robot Framework 2.7."},{"name":"Log File","args":"path, encoding=UTF-8","doc":"Wrapper for [Get File](#Get File) that also logs the returned file.\n\nThe file is logged with the INFO level. If you want something else, just use [Get File](#Get File) and the built-in keyword Log with the desired level."},{"name":"Move Directory","args":"source, destination","doc":"Moves the source directory into a destination.\n\nUses [Copy Directory](#Copy Directory) keyword internally, and source and destination arguments have exactly same semantics as with that keyword."},{"name":"Move File","args":"source, destination","doc":"Moves the source file into a new destination.\n\nUses [Copy File](#Copy File) keyword internally, and source and destination arguments have exactly same semantics as with that keyword."},{"name":"Normalize Path","args":"path","doc":"Normalizes the given path.\n\nExamples:\n\n```\n${path} =  Normalize Path  abc\n${p2} =  Normalize Path  abc/\n${p3} =  Normalize Path  abc/../def\n${p4} =  Normalize Path  abc/./def\n${p5} =  Normalize Path  abc//def\n```\n\n\\=>\n\n*   ${path} = 'abc'\n*   ${p2} = 'abc'\n*   ${p3} = 'def'\n*   ${p4} = 'abc/def'\n*   ${p5} = 'abc/def'"},{"name":"Read Process Output","args":"","doc":"Waits for a process to finish and returns its output.\n\nThis keyword waits for a process started with [Start Process](#Start Process) to end and then returns all output it has produced. The returned output contains everything the process has written into the standard output and error streams.\n\nThere is no need to use [Stop Process](#Stop Process) after using this keyword. Trying to read from an already stopped process fails.\n\nNote that although the process is finished, it still stays as the active process. Use [Switch Process](#Switch Process) to switch the active process or [Stop All Processes](#Stop All Processes) to reset the list of started processes."},{"name":"Remove Directory","args":"path, recursive=False","doc":"Removes the directory pointed to by the given path.\n\nIf the second argument recursive is set to any non-empty string, the directory is removed recursively. Otherwise removing fails if the directory is not empty.\n\nIf the directory pointed to by the path does not exist, the keyword passes, but it fails, if the path points to a file."},{"name":"Remove Environment Variable","args":"*names","doc":"Deletes the specified environment variable.\n\nDoes nothing if the environment variable is not set.\n\nStarting from Robot Framework 2.7, it is possible to remove multiple variables by passing them to this keyword as separate arguments."},{"name":"Remove File","args":"path","doc":"Removes a file with the given path.\n\nPasses if the file does not exist, but fails if the path does not point to a regular file (e.g. it points to a directory).\n\nThe path can be given as an exact path or as a glob pattern. The pattern matching syntax is explained in [introduction](#Introduction). If the path is a pattern, all files matching it are removed."},{"name":"Remove Files","args":"*paths","doc":"Uses [Remove File](#Remove File) to remove multiple files one-by-one.\n\nExample:\n\n```\nRemove Files  ${TEMPDIR}${/}foo.txt  ${TEMPDIR}${/}bar.txt  ${TEMPDIR}${/}zap.txt\n```"},{"name":"Run","args":"command","doc":"Runs the given command in the system and returns the output.\n\nThe execution status of the command **is not checked** by this keyword, and it must be done separately based on the returned output. If the execution return code is needed, either [Run And Return RC](#Run And Return Rc) or [Run And Return RC And Output](#Run And Return Rc And Output) can be used.\n\nThe standard error stream is automatically redirected to the standard output stream by adding 2>&1 after the executed command. This automatic redirection is done only when the executed command does not contain additional output redirections. You can thus freely forward the standard error somewhere else, for example, like my\\_command 2>stderr.txt.\n\nThe returned output contains everything written into the standard output or error streams by the command (unless either of them is redirected explicitly). Many commands add an extra newline (\\\\n) after the output to make it easier to read in the console. To ease processing the returned output, this possible trailing newline is stripped by this keyword.\n\nExamples:\n\n```\n${output} =  Run  ls -lhF /tmp\nLog  ${output}  \n${result} =  Run  ${CURDIR}${/}tester.py arg1 arg2\nShould Not Contain  ${result}  FAIL\n${stdout} =  Run  /opt/script.sh 2>/tmp/stderr.txt\nShould Be Equal  ${stdout}  TEST PASSED\nFile Should Be Empty  /tmp/stderr.txt  \n```"},{"name":"Run And Return Rc","args":"command","doc":"Runs the given command in the system and returns the return code.\n\nThe return code (RC) is returned as a positive integer in range from 0 to 255 as returned by the executed command. On some operating systems (notable Windows) original return codes can be something else, but this keyword always maps them to the 0-255 range. Since the RC is an integer, it must be checked e.g. with the keyword Should Be Equal As Integers instead of Should Be Equal (both are built-in keywords).\n\nExamples:\n\n```\n${rc} =  Run and Return RC  ${CURDIR}${/}script.py arg\nShould Be Equal As Integers  ${rc}  0\n${rc} =  Run and Return RC  /path/to/example.rb arg1 arg2\nShould Be True  0 < ${rc} < 42  \n```\n\nSee [Run](#Run) and [Run And Return RC And Output](#Run And Return Rc And Output) if you need to get the output of the executed command."},{"name":"Run And Return Rc And Output","args":"command","doc":"Runs the given command in the system and returns the RC and output.\n\nThe return code (RC) is returned similarly as with [Run And Return RC](#Run And Return Rc) and the output similarly as with [Run](#Run).\n\nExamples:\n\n```\n${rc}  ${output} =  Run and Return RC and Output  ${CURDIR}${/}mytool\nShould Be Equal As Integers  ${rc}  0  \nShould Not Contain  ${output}  FAIL  \n${rc}  ${stdout} =  Run and Return RC and Output  /opt/script.sh 2>/tmp/stderr.txt\nShould Be True  ${rc} > 42    \nShould Be Equal  ${stdout}  TEST PASSED  \nFile Should Be Empty  /tmp/stderr.txt    \n```"},{"name":"Set Environment Variable","args":"name, value","doc":"Sets an environment variable to a specified value.\n\nValues are converted to strings automatically. Starting from Robot Framework 2.7, set variables are automatically encoded using the system encoding."},{"name":"Set Modified Time","args":"path, mtime","doc":"Sets the file modification and access times.\n\nChanges the modification and access times of the given file to the value determined by mtime. The time can be given in different formats described below. Note that all checks involving strings are case-insensitive.\n\n1) If mtime is a number, or a string that can be converted to a number, it is interpreted as seconds since the UNIX epoch (1970-01-01 00:00:00 UTC). This documentation was originally written about 1177654467 seconds after the epoch.\n\n2) If mtime is a timestamp, that time will be used. Valid timestamp formats are 'YYYY-MM-DD hh:mm:ss' and 'YYYYMMDD hhmmss'.\n\n3) If mtime is equal to 'NOW', the current local time is used. This time is got using Python's 'time.time()' function.\n\n4) If mtime is equal to 'UTC', the current time in [UTC](http://en.wikipedia.org/wiki/Coordinated_Universal_Time) is used. This time is got using 'time.time() + time.altzone' in Python.\n\n5) If mtime is in the format like 'NOW - 1 day' or 'UTC + 1 hour 30 min', the current local/UTC time plus/minus the time specified with the time string is used. The time string format is described in an appendix of Robot Framework User Guide.\n\nExamples:\n\n```\nSet Modified Time  /path/file  1177654467  # Time given as epoch seconds\nSet Modified Time  /path/file  2007-04-27 9:14:27  # Time given as a timestamp\nSet Modified Time  /path/file  NOW  # The local time of execution\nSet Modified Time  /path/file  NOW - 1 day  # 1 day subtracted from the local time\nSet Modified Time  /path/file  UTC + 1h 2min 3s  # 1h 2min 3s added to the UTC time\n```\n\nSupport for UTC time is a new feature in Robot Framework 2.7.5."},{"name":"Should Exist","args":"path, msg=None","doc":"Fails unless the given path (file or directory) exists.\n\nThe path can be given as an exact path or as a glob pattern. The pattern matching syntax is explained in [introduction](#Introduction). The default error message can be overridden with the msg argument."},{"name":"Should Not Exist","args":"path, msg=None","doc":"Fails if the given path (file or directory) exists.\n\nThe path can be given as an exact path or as a glob pattern. The pattern matching syntax is explained in [introduction](#Introduction). The default error message can be overridden with the msg argument."},{"name":"Split Extension","args":"path","doc":"Splits the extension from the given path.\n\nThe given path is first normalized (e.g. possible trailing path separators removed, special directories '..' and '.' removed). The base path and extension are returned as separate components so that the dot used as an extension separator is removed. If the path contains no extension, an empty string is returned for it. Possible leading and trailing dots in the file name are never considered to be extension separators.\n\nExamples:\n\n```\n${path}  ${ext} =  Split Extension  file.extension\n${p2}  ${e2} =  Split Extension  path/file.ext\n${p3}  ${e3} =  Split Extension  path/file\n${p4}  ${e4} =  Split Extension  p1/../p2/file.ext\n${p5}  ${e5} =  Split Extension  path/.file.ext\n${p6}  ${e6} =  Split Extension  path/.file\n```\n\n\\=>\n\n*   ${path} = 'file' & ${ext} = 'extension'\n*   ${p2} = 'path/file' & ${e2} = 'ext'\n*   ${p3} = 'path/file' & ${e3} = ''\n*   ${p4} = 'p2/file' & ${e4} = 'ext'\n*   ${p5} = 'path/.file' & ${e5} = 'ext'\n*   ${p6} = 'path/.file' & ${e6} = ''"},{"name":"Split Path","args":"path","doc":"Splits the given path from the last path separator ('/' or '\\\\').\n\nThe given path is first normalized (e.g. a possible trailing path separator is removed, special directories '..' and '.' removed). The parts that are split are returned as separate components.\n\nExamples:\n\n```\n${path1}  ${dir} =  Split Path  abc/def\n${path2}  ${file} =  Split Path  abc/def/ghi.txt\n${path3}  ${d2} =  Split Path  abc/../def/ghi/\n```\n\n\\=>\n\n*   ${path1} = 'abc' & ${dir} = 'def'\n*   ${path2} = 'abc/def' & ${file} = 'ghi.txt'\n*   ${path3} = 'def' & ${d2} = 'ghi'"},{"name":"Start Process","args":"command, stdin=None, alias=None","doc":"Starts the given command as a background process.\n\nStarts the process in background and sets it as the active process. [Read Process Output](#Read Process Output) or [Stop Process](#Stop Process) keywords affect this process unless [Switch Process](#Switch Process) is used in between.\n\nIf the command needs input through the standard input stream, it can be defined with the stdin argument. It is not possible to give input to the command later. Possible command line arguments must be given as part of the command like '/tmp/script.sh arg1 arg2'.\n\nReturns the index of this process. Indexing starts from 1, and indices can be used to switch between processes using [Switch Process](#Switch Process) keyword. [Stop All Processes](#Stop All Processes) can be used to reset indexing.\n\nThe optional alias is a name for this process that may be used with [Switch Process](#Switch Process) instead of the returned index.\n\nThe standard error stream is redirected to the standard input stream automatically. This is done for the same reasons as with [Run](#Run) keyword, but redirecting is done when the process is started and not by adding '2>&1' to the command.\n\nExample:\n\n```\nStart Process  /path/longlasting.sh  \nDo Something    \n${output} =  Read Process Output  \nShould Contain  ${output}  Expected text\n[Teardown]  Stop All Processes  \n```"},{"name":"Stop All Processes","args":"","doc":"Closes the standard output of all the processes and resets the process list.\n\nExactly like [Stop Process](#Stop Process), this keyword does not actually stop processes nor even wait for them to terminate.\n\nThis keyword resets the indexing that [Start Process](#Start Process) uses. All aliases are also deleted. It does not matter have some of the processes already been closed or not."},{"name":"Stop Process","args":"","doc":"Closes the standard output stream of the process.\n\nThis keyword does not actually stop the process nor even wait for it to terminate. Only thing it does is closing the standard output stream of the process. Depending on the process that may terminate it but that is not guaranteed. Use [Read Process Output](#Read Process Output) instead if you need to wait for the process to complete.\n\nThis keyword operates the active process similarly as [Read Process Output](#Read Process Output). Stopping an already stopped process is not an error."},{"name":"Switch Process","args":"index_or_alias","doc":"Switches the active process to the specified process.\n\nNew active process can be specified either using an index or an alias. Indices are return values from [Start Process](#Start Process) and aliases can be given to that keyword.\n\nExample:\n\n```\nStart Process  /path/script.sh arg  alias=1st process\n${2nd} =  Start Process  /path/script2.sh\nSwitch Process  1st process  \n${out1} =  Read Process Output  \nSwitch Process  ${2nd}  \n${out2} =  Read Process Output  \nLog Many  1st process: ${out1}  2nd process: ${out1}\n[Teardown]  Stop All Processes  \n```"},{"name":"Touch","args":"path","doc":"Emulates the UNIX touch command.\n\nCreates a file, if it does not exist. Otherwise changes its access and modification times to the current time.\n\nFails if used with the directories or the parent directory of the given file does not exist."},{"name":"Wait Until Created","args":"path, timeout=1 minute","doc":"Waits until the given file or directory is created.\n\nThe path can be given as an exact path or as a glob pattern. The pattern matching syntax is explained in [introduction](#Introduction). If the path is a pattern, the keyword returns when an item matching it is created.\n\nThe optional timeout can be used to control the maximum time of waiting. The timeout is given as a timeout string, e.g. in a format '15 seconds', '1min 10s' or just '10'. The time string format is described in an appendix of Robot Framework User Guide.\n\nIf the timeout is negative, the keyword is never timed-out. The keyword returns immediately, if the path already exists."},{"name":"Wait Until Removed","args":"path, timeout=1 minute","doc":"Waits until the given file or directory is removed.\n\nThe path can be given as an exact path or as a glob pattern. The pattern matching syntax is explained in [introduction](#Introduction). If the path is a pattern, the keyword waits until all matching items are removed.\n\nThe optional timeout can be used to control the maximum time of waiting. The timeout is given as a timeout string, e.g. in a format '15 seconds', '1min 10s' or just '10'. The time string format is described in an appendix of Robot Framework User Guide.\n\nIf the timeout is negative, the keyword is never timed-out. The keyword returns immediately, if the path does not exist in the first place."}]}