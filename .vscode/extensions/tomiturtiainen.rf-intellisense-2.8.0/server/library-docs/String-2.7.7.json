{"name":"String","version":"2.7.7","keywords":[{"name":"Decode Bytes To String","args":"bytes, encoding, errors=strict","doc":"Decodes the given bytes to a Unicode string using the given encoding.\n\nerrors argument controls what to do if decoding some bytes fails. All values accepted by decode method in Python are valid, but in practice the following values are most useful:\n\n*   strict: fail if characters cannot be decoded (default)\n*   ignore: ignore characters that cannot be decoded\n*   replace: replace characters that cannot be decoded with a replacement character\n\nExamples:\n\n```\n${string} =  Decode Bytes To String  ${bytes}  UTF-8  \n${string} =  Decode Bytes To String  ${bytes}  ASCII  errors=ignore\n```\n\nUse [Encode String To Bytes](#Encode String To Bytes) if you need to convert Unicode strings to byte strings, and Convert To String in BuiltIn if you need to convert arbitrary objects to Unicode strings.\n\nNew in Robot Framework 2.7.7."},{"name":"Encode String To Bytes","args":"string, encoding, errors=strict","doc":"Encodes the given Unicode string to bytes using the given encoding.\n\nerrors argument controls what to do if encoding some characters fails. All values accepted by encode method in Python are valid, but in practice the following values are most useful:\n\n*   strict: fail if characters cannot be encoded (default)\n*   ignore: ignore characters that cannot be encoded\n*   replace: replace characters that cannot be encoded with a replacement character\n\nExamples:\n\n```\n${bytes} =  Encode String To Bytes  ${string}  UTF-8  \n${bytes} =  Encode String To Bytes  ${string}  ASCII  errors=ignore\n```\n\nUse [Decode Bytes To String](#Decode Bytes To String) if you need to convert byte strings to Unicode strings, and Convert To String in BuiltIn if you need to convert arbitrary objects to Unicode strings.\n\nNew in Robot Framework 2.7.7."},{"name":"Fetch From Left","args":"string, marker","doc":"Returns contents of the string before the first occurrence of marker.\n\nIf the marker is not found, whole string is returned.\n\nSee also [Fetch From Right](#Fetch From Right), [Split String](#Split String) and [Split String From Right](#Split String From Right)."},{"name":"Fetch From Right","args":"string, marker","doc":"Returns contents of the string after the last occurrence of marker.\n\nIf the marker is not found, whole string is returned.\n\nSee also [Fetch From Left](#Fetch From Left), [Split String](#Split String) and [Split String From Right](#Split String From Right)."},{"name":"Generate Random String","args":"length=8, chars=[LETTERS][NUMBERS]","doc":"Generates a string with a desired length from the given chars.\n\nThe population sequence chars contains the characters to use when generating the random string. It can contain any characters, and it is possible to use special markers explained in the table below:\n\n```\n[LOWER]  Lowercase ASCII characters from 'a' to 'z'.\n[UPPER]  Uppercase ASCII characters from 'A' to 'Z'.\n[LETTERS]  Lowercase and uppercase ASCII characters.\n[NUMBERS]  Numbers from 0 to 9.\n```\n\nExamples:\n\n```\n${ret} =  Generate Random String    \n${low} =  Generate Random String  12  [LOWER]\n${bin} =  Generate Random String  8  01\n${hex} =  Generate Random String  4  [NUMBERS]abcdef\n```"},{"name":"Get Line","args":"string, line_number","doc":"Returns the specified line from the given string.\n\nLine numbering starts from 0 and it is possible to use negative indices to refer to lines from the end. The line is returned without the newline character.\n\nExamples:\n\n```\n${first} =  Get Line  ${string}  0\n${2nd last} =  Get Line  ${string}  -2\n```"},{"name":"Get Line Count","args":"string","doc":"Returns and logs the number of lines in the given string."},{"name":"Get Lines Containing String","args":"string, pattern, case_insensitive=False","doc":"Returns lines of the given string that contain the pattern.\n\nThe pattern is always considered to be a normal string and a line matches if the pattern is found anywhere in it. By default the match is case-sensitive, but setting case\\_insensitive to any value makes it case-insensitive.\n\nLines are returned as one string catenated back together with newlines. Possible trailing newline is never returned. The number of matching lines is automatically logged.\n\nExamples:\n\n```\n${lines} =  Get Lines Containing String  ${result}  An example  \n${ret} =  Get Lines Containing String  ${ret}  FAIL  case-insensitive\n```\n\nSee [Get Lines Matching Pattern](#Get Lines Matching Pattern) and [Get Lines Matching Regexp](#Get Lines Matching Regexp) if you need more complex pattern matching."},{"name":"Get Lines Matching Pattern","args":"string, pattern, case_insensitive=False","doc":"Returns lines of the given string that match the pattern.\n\nThe pattern is a _glob pattern_ where:\n\n```\n*  matches everything\n?  matches any single character\n[chars]  matches any character inside square brackets (e.g. '[abc]' matches either 'a', 'b' or 'c')\n[!chars]  matches any character not inside square brackets\n```\n\nA line matches only if it matches the pattern fully. By default the match is case-sensitive, but setting case\\_insensitive to any value makes it case-insensitive.\n\nLines are returned as one string catenated back together with newlines. Possible trailing newline is never returned. The number of matching lines is automatically logged.\n\nExamples:\n\n```\n${lines} =  Get Lines Matching Pattern  ${result}  Wild???? example  \n${ret} =  Get Lines Matching Pattern  ${ret}  FAIL: *  case-insensitive\n```\n\nSee [Get Lines Matching Regexp](#Get Lines Matching Regexp) if you need more complex patterns and [Get Lines Containing String](#Get Lines Containing String) if searching literal strings is enough."},{"name":"Get Lines Matching Regexp","args":"string, pattern","doc":"Returns lines of the given string that match the regexp pattern.\n\nSee BuiltIn.Should Match Regexp for more information about Python regular expression syntax in general and how to use it in Robot Framework test data in particular. A line matches only if it matches the pattern fully. Notice that to make the match case-insensitive, you need to embed case-insensitive flag into the pattern.\n\nLines are returned as one string catenated back together with newlines. Possible trailing newline is never returned. The number of matching lines is automatically logged.\n\nExamples:\n\n```\n${lines} =  Get Lines Matching Regexp  ${result}  Reg\\\\w{3} example\n${ret} =  Get Lines Matching Regexp  ${ret}  (?i)FAIL: .*\n```\n\nSee [Get Lines Matching Pattern](#Get Lines Matching Pattern) and [Get Lines Containing String](#Get Lines Containing String) if you do not need full regular expression powers (and complexity)."},{"name":"Get Substring","args":"string, start, end=None","doc":"Returns a substring from start index to end index.\n\nThe start index is inclusive and end is exclusive. Indexing starts from 0, and it is possible to use negative indices to refer to characters from the end.\n\nExamples:\n\n```\n${ignore first} =  Get Substring  ${string}  1  \n${ignore last} =  Get Substring  ${string}    -1\n${5th to 10th} =  Get Substring  ${string}  4  10\n${first two} =  Get Substring  ${string}    1\n${last two} =  Get Substring  ${string}  -2  \n```"},{"name":"Replace String","args":"string, search_for, replace_with, count=-1","doc":"Replaces search\\_for in the given string with replace\\_with.\n\nsearch\\_for is used as a literal string. See [Replace String Using Regexp](#Replace String Using Regexp) if more powerful pattern matching is needed.\n\nIf the optional argument count is given, only that many occurrences from left are replaced. Negative count means that all occurrences are replaced (default behaviour) and zero means that nothing is done.\n\nA modified version of the string is returned and the original string is not altered.\n\nExamples:\n\n```\n${str} =  Replace String  ${str}  Hello  Hi  \n${str} =  Replace String  ${str}  world  tellus  1\n```"},{"name":"Replace String Using Regexp","args":"string, pattern, replace_with, count=-1","doc":"Replaces pattern in the given string with replace\\_with.\n\nThis keyword is otherwise identical to [Replace String](#Replace String), but the pattern to search for is considered to be a regular expression. See BuiltIn.Should Match Regexp for more information about Python regular expression syntax in general and how to use it in Robot Framework test data in particular.\n\nExamples:\n\n```\n${str} =  Replace String Using Regexp  ${str}  (Hello|Hi)  Hei  \n${str} =  Replace String Using Regexp  ${str}  20\\\\d\\\\d-\\\\d\\\\d-\\\\d\\\\d  <DATE>  2\n```"},{"name":"Should Be Byte String","args":"item, msg=None","doc":"Fails if the given item is not a byte string.\n\nUse [Should Be Unicode String](#Should Be Unicode String) if you want to verify the item is a Unicode string, or [Should Be String](#Should Be String) if both Unicode and byte strings are fine.\n\nThe default error message can be overridden with the optional msg argument.\n\nNew in Robot Framework 2.7.7."},{"name":"Should Be Lowercase","args":"string, msg=None","doc":"Fails if the given string is not in lowercase.\n\nFor example 'string' and 'with specials!' would pass, and 'String', '' and ' ' would fail.\n\nThe default error message can be overridden with the optional msg argument.\n\nSee also [Should Be Uppercase](#Should Be Uppercase) and [Should Be Titlecase](#Should Be Titlecase). All these keywords were added in Robot Framework 2.1.2."},{"name":"Should Be String","args":"item, msg=None","doc":"Fails if the given item is not a string.\n\nThis keyword passes regardless is the item is a Unicode string or a byte string. Use [Should Be Unicode String](#Should Be Unicode String) or [Should Be Byte String](#Should Be Byte String) if you want to restrict the string type.\n\nThe default error message can be overridden with the optional msg argument."},{"name":"Should Be Titlecase","args":"string, msg=None","doc":"Fails if given string is not title.\n\nstring is a titlecased string if there is at least one character in it, uppercase characters only follow uncased characters and lowercase characters only cased ones.\n\nFor example 'This Is Title' would pass, and 'Word In UPPER', 'Word In lower', '' and ' ' would fail.\n\nThe default error message can be overridden with the optional msg argument.\n\nSee also [Should Be Uppercase](#Should Be Uppercase) and [Should Be Lowercase](#Should Be Lowercase). All theses keyword were added in Robot Framework 2.1.2."},{"name":"Should Be Unicode String","args":"item, msg=None","doc":"Fails if the given item is not a Unicode string.\n\nUse [Should Be Byte String](#Should Be Byte String) if you want to verify the item is a byte string, or [Should Be String](#Should Be String) if both Unicode and byte strings are fine.\n\nThe default error message can be overridden with the optional msg argument.\n\nNew in Robot Framework 2.7.7."},{"name":"Should Be Uppercase","args":"string, msg=None","doc":"Fails if the given string is not in uppercase.\n\nFor example 'STRING' and 'WITH SPECIALS!' would pass, and 'String', '' and ' ' would fail.\n\nThe default error message can be overridden with the optional msg argument.\n\nSee also [Should Be Titlecase](#Should Be Titlecase) and [Should Be Lowercase](#Should Be Lowercase). All these keywords were added in Robot Framework 2.1.2."},{"name":"Should Not Be String","args":"item, msg=None","doc":"Fails if the given item is a string.\n\nThe default error message can be overridden with the optional msg argument."},{"name":"Split String","args":"string, separator=None, max_split=-1","doc":"Splits the string using separator as a delimiter string.\n\nIf a separator is not given, any whitespace string is a separator. In that case also possible consecutive whitespace as well as leading and trailing whitespace is ignored.\n\nSplit words are returned as a list. If the optional max\\_split is given, at most max\\_split splits are done, and the returned list will have maximum max\\_split + 1 elements.\n\nExamples:\n\n```\n@{words} =  Split String  ${string}      \n@{words} =  Split String  ${string}  ,${SPACE}    \n${pre}  ${post} =  Split String  ${string}  ::  1\n```\n\nSee [Split String From Right](#Split String From Right) if you want to start splitting from right, and [Fetch From Left](#Fetch From Left) and [Fetch From Right](#Fetch From Right) if you only want to get first/last part of the string."},{"name":"Split String From Right","args":"string, separator=None, max_split=-1","doc":"Splits the string using separator starting from right.\n\nSame as [Split String](#Split String), but splitting is started from right. This has an effect only when max\\_split is given.\n\nExamples:\n\n```\n${first}  ${others} =  Split String  ${string}  -  1\n${others}  ${last} =  Split String From Right  ${string}  -  1\n```"},{"name":"Split String To Characters","args":"string","doc":"Splits the string\\` to characters.\n\nExample:\n\n```\n@{characters} =  Split String To Characters  ${string}\n```"},{"name":"Split To Lines","args":"string, start=0, end=None","doc":"Converts the string into a list of lines.\n\nIt is possible to get only a selection of lines from start to end so that start index is inclusive and end is exclusive. Line numbering starts from 0, and it is possible to use negative indices to refer to lines from the end.\n\nLines are returned without the newlines. The number of returned lines is automatically logged.\n\nExamples:\n\n```\n@{lines} =  Split To Lines  ${manylines}    \n@{ignore first} =  Split To Lines  ${manylines}  1  \n@{ignore last} =  Split To Lines  ${manylines}    -1\n@{5th to 10th} =  Split To Lines  ${manylines}  4  10\n@{first two} =  Split To Lines  ${manylines}    1\n@{last two} =  Split To Lines  ${manylines}  -2  \n```\n\nUse [Get Line](#Get Line) if you only need to get a single line."}]}